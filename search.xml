<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[node.js 启动流程解析]]></title>
    <url>%2Fpost-16%2F</url>
    <content type="text"><![CDATA[该版本是 node.js 的 Version 13，通过 VS Code 一步一步调试，大致了解了 node 的启动流程，同时也对 C++ 的语法和使用有了一些了解 从入口开始 在 node_main.cc 文件中，这一行就是本次旅程的起点，node::start 启动并将 argc ( node 接收到的参数总数)和 argv (参数地址)传入。 InitializeOncePerProcess 在 node.cc文件中，这行是开始初始化进程，从名字可以看出，这里保证只执行一次 atexit 函数，从命名可以知道这个是在程序即将结束时会被触发，resetStdio 函数用来对标准 I/O 资源的回收，包括文件描述符 fd 和 tty 相关的。 PlatformInitPlatformInit 函数，主要是对不同平台进行兼容并做一些平台相关的初始化工作，例如这里就是对文件描述符 fd 的初始化，确保进程中 fd 0(stdin)、1(stdout)、2(stderr) 是正常的， fstat 会返回文件的相关信息，535 行的作用是保证 fd 为 0 1 2 的值都已经被占用，fd 分配从 3 开始，fd 表示的是进程能打开的文件数，系统默认是 1024 定义并初始化 act 变量，根据系统的 signal 值，对不同的 signal 注册触发函数 通过 fcntl 函数读取文件的文件描述符标记，fcntl 的文件状态标志总共有 7 个：O_RDONLY , O_WRONLY , O_RDWR , O_APPEND , O_NONBLOCK , O_SYNC 和 O_ASYNC RegisterSignalHandler 注册系统信号的触发函数，上面的是进程结束时的信号，SIGINT 当我们敲 c t r l + c 时会发出，SIGTERM 该信号可以被阻塞，等待合适时机再进行退出处理，而 SIGKILL 信号则是不能被捕获的，一旦发出则程序一定会退出，例如 kill -9 命令就会发出该信号 getrlimit 是用来获取系统限定资源信息的函数， RLIMIT_NOFILE 的意思就是获取最大的文件描述符数，分为软限制和硬限制，软限制的值不能大于硬限制，这里利用二分搜索找出系统能设置的最大值 uv_setup_args uv_setup_args 的作用是复制一份命令行的参数，用于赋值给 process.title InitializeNodeWithArgs RegisterBuiltinModules node_biding.cc RegisterBuiltinModules 注册内置模块，使用了宏的写法，这些模块就是在 no de_XX.cc 中的模块，生成一个 modlist_internal 链表中借助 nm_link 指针指向下一个模块 接下来是一些 Node 环境变量的配置 把命令行中的配置项，例如 – 或者 - 开头的从 argv 分离到 exec_argv 中 InitializeCodeCache node_code_cache.cc 这一步把提前编译好的 lib 下的 js 文件都存放在 code_cache 的 map 中，免去了读入文件的过程，加快启动速度 如果使用了 openssl 则使用 ca 证书，借助 BIO 进行读取 per_process::v8_platform.Initializenode_v8_platform-inl.h node_platform.cc 初始化 V8 平台相关的准备工作，包括添加运行状态追踪，生成 node 平台实例，配置多线程的线程池资源 v8::V8::InitializePlatformapi.cc v8.cc 初始化 V8 平台，包括调用栈追踪和调用栈等功能的初始化 node 的代码中很多 v8::XX 和 v8::internal::XX 的转换，等于是在中间加多了一层，对外暴露的 API 是 v8::XX，而 v8::internal::XX 则是内部实现，这样可以将代码分离，内部的变更都不会影响外部 API V8::Initializenode.cc v8::internal::V8::InitializeOncePerProcessv8.cc 这里从命名就可以看出是只会执行一次的逻辑，类似的变量均被定义为 OnceType 类型，该类型的实质是 C++ 中的 std::atomic，该类型是用来多线程中避免竞争的原子操作原语，而 init_once 则是 OnceType 类型 load 和 store 是读写值时使用的函数， Memory Order 意思是内存顺序，是 CPU 对指令执行优化引申的一个概念，多线程的同步机制一般有 mutex 和 atomic，前者性能消耗大于后者。 once.cc 此处的 memory_order_acquire 对应的是 release-acquire 机制，保证了线程读写对其他线程的可见性，这里我们可以看到 callOnceImpl 的实现，如果 once 的状态为已完成则直接返回，否则初始化一个 expected 变量赋值为初始态，compare_exchange_strong 的作用就是做一次 CAS(compare and swap) 如果变量的值符合预期，即 初始态 ，那么就更新变量的状态为 执行中 ，执行 init_func 结束后，将变量状态设置为 结束态 ，如果 CAS 操作没有成功，且此时状态为 执行中 ，就调用sched_yield 交出执行权，这里的机制类似 JS 的 generator V8::InitializeOncePerProcessImplv8.cc 这里主要是做了各种初始化操作，包括 OS ，Isolate 的线程标识 ，还注册了一系列 v8 扩展 至此 node::Start 中的 InitializeOncePerProcess 完成 Node::Startnode.cc 初始化 params 用于 Isolate 的初始化，然后获取 snapshot(快照) ，这是 Node 引入的加快启动速度的优化，将 Isolate 和 Context 的部分初始值序列化后嵌入程序中，然后后续的初始化可以复用他们之前的 snapshot main_instance 生成 main_instance 实例，将 Isolate 的 params ，libuv ，先前生成的 v8_platform ，命令行参数 args ，带 – 或 - 的参数 exec_args 传入 node_main_instance.cc isolate.cc 第 71 行 为 Isolate 初始化做前期工作，在第 2819 行初始化 Isolate 实例，isolatedata 保存了 Isolate 数据，isolateallocator 保存了 Isolate 的内存地址，接着初始化了线程管理器 ThreadManager ，最后初始化了微任务队列 MicrotaskQueue 这是一个双向循环链表 第 75 行在 platform 中注册 Isolate ，将该 Isolate 和 eventloop 的信息记录在 map 中，便于多 Isolate 条件下的查找 第 76 行根据 params 的值设置 node 的 heap 堆内存资源额度，包括新生代，老生代，semispace 第 77 行真正初始化 Isolate，根据 params 为 Isolate 赋值 api.cc 这里设置了堆栈的资源额度限制真正开始生效，第 8224 行从 snapshot 中获取部分数据赋值给 Isolate isolate_scope 负责记录 isolate 被线程访问的情况，通过 EntryStackItem 记录 至此，Isolate 的初始化正式完成 保存一份 IsolateData 在 NodeMainInstance NodeMainInstance::Run 启动的前期工作准备就绪，这时候开始运行 main_instance HandleSope 经常能在代码中看到，这等于是开拓了一片作用域，在这之后的Local 变量都会被纳入 V8 的内存管理，在代码运行结束后资源能够被 GC 回收，这是一个简化的操作，实现原理是通过生成实例时调用 enter 方法，然后再运行结束时 C++会自动调用析构函数，这时候调用 exit 方法，起到了自动管理的作用 NodeMainInstance::CreateMainEnvironment 这里根据 snapshot 初始化 context ，下面的 context_scope 作用同上，其中的context 会被注入到 JS 中作为全局的 global 对象 生成指向 Environment 的指针，这个时候会实例化 Environment，然后生成 node 中的 process 和 primordials 对象，准备注入到 Js 中 接下来开始初始化 libuv 和 诊断相关的逻辑 注册不同阶段的 handle Environment::RunBootstrapping 运行 JS 代码，lib/internal 中的 loaders 和 node FIXED_ONE_BYTE_STRING 作用是将 string 转换为 Local 运行 internal/bootstrap/loaders 文件的逻辑，同时注入 process ，getLinkedBinding，getInternalBinding，primordials，这样在 Js 文件内部就可以访问到 loader_exports 返回的是 JS 文件中 return 的 loader_exports 对象，包括 require 方法， internalBinding 方法 EscapableHandleScope 的作用是用来要把内部的 Local 类型往外返回的时候，避免被 v8 回收 执行 ExecuteBootstrapper 中的 NativeModuleEnv::LookupAndCompile 拿到 JS 的内容后，调用 -&gt;Call 进行调用 LoadBuiltinModuleSource 中根据 Id ，即路径名查询， source_ 中是提前嵌入的 lib 下的 Js 文件，如果命中则直接将对应的字符串赋值给 source，然后将文件的基本信息保存在 origin 中 利用 ScriptCompiler::CompileFunctionInContext 注入 Context，然后缓存到 codecache 注入 process.env 至此 env-&gt;RunBootstrapping() 完成，CreateMainEnvironment 结束 调用 LoadEnvironment 装载环境，根据不同的命令行参数运行不同的 JS文件，一般情况下，internal/main/run_main_module 最后运行 uv_run ，启动 event loop，如果没有 active handle ，那么就准备释放资源和退出程序]]></content>
      <tags>
        <tag>frontend</tag>
        <tag>node</tag>
        <tag>v8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说说 Generator]]></title>
    <url>%2Fpost-15%2F</url>
    <content type="text"><![CDATA[一、什么是 Generator The Generator object is returned by a generator function and it conforms to both the iterable protocol and the iterator protocol. 生成器对象是由一个 generator function 返回的,并且它符合可迭代协议和迭代器协议。 可迭代协议可迭代协议是指允许 JavaScript 对象（可迭代对象）去定义或定制它们的迭代行为，这个对象（或其原型链中的任意一个对象）必须具有一个带 Symbol.iterator键的属性，其值返回一个对象的无参函数，被返回对象符合迭代器协议 迭代器协议迭代器协议定义了一种标准的方式来产生一个有限或无限序列的值，并且当所有的值都已经被迭代后，就会有一个默认的返回值 迭代器需要实现 next() 方法，返回一个对象的无参函数，被返回对象拥有两个属性，分别是 (done :Boolean) 迭代器已经超过了可迭代次数时为 true，这时 value 的值可以被省略，除非该迭代器 return 了某个值 1234567891011121314151617181920var iterable = &#123; *[Symbol.iterator](n) &#123; yield 1; yield (n || 0) + 2; yield 3; &#125;&#125;;for (let value of iterable) &#123; console.log(value); // 1 2 3&#125;console.log(...iterable[Symbol.iterator](4)); // 1 6 3console.log(iterable[Symbol.iterator](4).next());/*Object &#123; done: false, value: 1&#125;*/ 生成器函数生成器函数的定义和普通函数类似，只是需要在函数名前关键字 function 后添加 * 号 funtion* generator(){}，需要注意的是，生成器函数不能作为构造函数 调用生成器函数后会返回一个生成器对象，该对象是个可迭代对象，同时实现了 next 方法，所以也是一个迭代器，即生成器既是迭代器也是可迭代对象 yield 表达式就是用来表示迭代暂停的位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263function* demo(d) &#123; yield 10; x = yield d; yield x;&#125;const gen = demo(666);gen.next(); // 10gen.next(); // 666gen.next(); // undefinedgen.next(); // undefined/*Object &#123; done: false, value: 10&#125;*//*Object &#123; done: false, value: 666&#125;*//*Object &#123; done: false, value: undefined&#125;*//*Object &#123; done: true, value: undefined&#125;*/// 以下省略next（）返回对象，只表 value 值const gen = demo(666);gen.next(); // 10gen.next(55); // 666gen.next(); // 55gen.next(); // undefinedfunction* demo1(d) &#123; try &#123; yield 10; &#125; catch (e) &#123; console.log(e); // 55 x = yield d; yield x; &#125;&#125;const gen = demo1(666);gen.next(); // 10 falsegen.return(55); // 55 truegen.next(); // undefined truegen.next(); // undefined trueconst gen = demo1(666);gen.next(); // 10 falsegen.throw(55); // 666 truegen.next(); // undefined truegen.next(); // undefined true 从上面的例子我们能看出来，执行 next() 的时候，代码的运行会到 yield 关键字的右侧，这时返回的值就是 yield 右侧的语句执行的结果，而 next() 中的传参则会被赋值到 yield 左侧，即作为 yield 的返回值使用。 如果生成器对象调用 throw 方法，那么能够被 tryCatch 捕获到，并且在 catch 的 body 中可以继续执行 如果生成器对象调用 return 方法，那么函数立即返回，同时后续的 yield都不会被执行，等同于函数在该语句的位置被 return 了 yield 和 yield*yield* 表达式用于委托给另一个可迭代对象 123456789101112131415161718192021222324252627282930313233343536function* g1() &#123; yield 2; yield 3; yield 4;&#125;function* g2() &#123; yield 1; // 嵌套生成器 yield* g1(); yield g1(); yield* [5, yield "hi4", 6, yield* "hi"]; // [5,undefined,6,undefined] 第一个是因为next()没有参数导致的，第二个是因为 yield* 没有 return 结果 yield [7, 8]; yield 9;&#125;var iterator = g2();console.log(iterator.next()); // &#123; value: 1, done: false &#125;console.log(iterator.next()); // &#123; value: 2, done: false &#125;console.log(iterator.next()); // &#123; value: 3, done: false &#125;console.log(iterator.next()); // &#123; value: 4, done: false &#125;console.log(iterator.next()); // &#123; value: [object Generator] &#123;&#125;, done: false &#125;console.log(iterator.next()); // &#123; value: 'hi4', done: false &#125;console.log(iterator.next()); // &#123; value: 'h', done: false &#125;console.log(iterator.next()); // &#123; value: 'i', done: false &#125;console.log(iterator.next()); // &#123; value: '5', done: false &#125;console.log(iterator.next()); // &#123; value: undefined, done: false &#125;console.log(iterator.next()); // &#123; value: '6', done: false &#125;console.log(iterator.next()); // &#123; value: undefined, done: false &#125;console.log(iterator.next()); // &#123; value: [7,8], done: false &#125;console.log(iterator.next()); // &#123; value: 9, done: false &#125;console.log(iterator.next()); // &#123; value: undefined, done: true &#125; 从上面的例子可以看出，yield* 的作用实质上是解决嵌套可迭代对象（arguments，array，string，set，map 等都是可迭代的）的问题，更像是个语法糖，同时其 yield 还有一个区别是它是表达式，所以会有自己的返回值，而 yield 的返回值由 next() 参数所决定。 二、意义（解决什么问题）协程与化异步为同步写法与协程相关的是进程、线程，进程是计算机资源分配的基本单位，线程是执行的基本单位。 计算机将存储资源分配给进程之后，进程就可以利用这些资源进行计算，进程可以生成线程去执行语句，线程间可以使用共享内存进行通讯，而协程则是更精细化的资源管理。为了防止某一进程占用过多资源，Cpu 有一套调度算法，随着粒度越细，切换的时候的消耗就越小，协程则可以理解成是在某个线程中的多线程而这个切换过程是无需系统参与的，也就少了系统调用，同时也是在同一个栈上切换的，例如 Go 的 coroutine 就是占用更少的资源，进行更精细的调度。 generator 的暂停执行特性，可以将函数执行的控制权交出，JS 的单线程特性使得可以利用 generator 实现协程，其中的关键在于实现流程自动调度功能。 JS 是运行在单线程中的，为了提高效率，引入了异步方式，当运行一些远程 IO 或者网络请求的时候可以无需等待直接往下执行，等拿到响应之后再执行回调。这就引入了一个典型的问题，就是回调嵌套地狱(callback hell)。 当引入了 generator 后，异步的代码就可以写成同步的方式，降低认知成本，提高代码可读性 1234567891011121314151617doAsync1(str, res1 =&gt; &#123; doAsync2(res1, res2 =&gt; &#123; doAsync3(res2, res3 =&gt; &#123;&#125;); &#125;);&#125;);function* doAsync(str) &#123; const res1 = yield doAsync1(str); const res2 = yield doAsync2(res1); const res3 = yield doAsync3(res2); console.log(res3);&#125;const gen = doAsync(str);const async1 = gen.next().value;const async2 = gen.next(async1).value;const async3 = gen.next(async2).value; 三、实践和库（ co 和 redux-saga）co 和 redux-saga 的核心代码是类似的，都实现了一套流程自动调度，redux-saga 在此基础上添加了更多的功能 123456789const it = gen();function next(res) &#123; if (!it.done) &#123; const ret = it.next(res); next(ret.value); &#125;&#125;next(); coco 库主要做的一件事情就是为 generator 包裹一层 promise，然后通过 then 将控制权返回，同时对于 generator 实现了流程的自动调度，对于对象和数组类型还支持并发调用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// 将对象的value值转化为promise数组 在用Promise.all实现并发function objectToPromise(obj) &#123; var results = new obj.constructor(); var keys = Object.keys(obj); var promises = []; for (var i = 0; i &lt; keys.length; i++) &#123; var key = keys[i]; // 将非promise类型转为promise var promise = toPromise.call(this, obj[key]); if (promise &amp;&amp; isPromise(promise)) defer(promise, key); else results[key] = obj[key]; &#125; // 并发调用 return Promise.all(promises).then(function() &#123; return results; &#125;); function defer(promise, key) &#123; results[key] = undefined; // 返回值以对象形式返回 promises.push( promise.then(function(res) &#123; results[key] = res; &#125;) ); &#125;&#125;// 将数组中的非promise类型元素转为promisefunction arrayToPromise(obj) &#123; return Promise.all(obj.map(toPromise, this));&#125;// 主体部分非常简洁function co(gen) &#123; var ctx = this; var args = slice.call(arguments, 1); return new Promise(function(resolve, reject) &#123; if (typeof gen === "function") gen = gen.apply(ctx, args); if (!gen || typeof gen.next !== "function") return resolve(gen); onFulfilled(); function onFulfilled(res) &#123; var ret; try &#123; // 执行相邻 yield 之间语句, res 为上一个 yield 左侧值，即yield右侧语句执行后返回值 ret = gen.next(res); &#125; catch (e) &#123; // 捕获异常抛出错误 return reject(e); &#125; //递归调用，将 yield 右侧的值赋值给 yield 的左侧 next(ret); return null; &#125; function onRejected(err) &#123; var ret; try &#123; ret = gen.throw(err); &#125; catch (e) &#123; return reject(e); &#125; next(ret); &#125; function next(ret) &#123; // 递归结束后 将return值 返回 if (ret.done) return resolve(ret.value); var value = toPromise.call(ctx, ret.value); if (value &amp;&amp; isPromise(value)) // 递归调用promise return value.then(onFulfilled, onRejected); return onRejected( new TypeError( "You may only yield a function, promise, generator, array, or object, " + 'but the following object was passed: "' + String(ret.value) + '"' ) ); &#125; &#125;);&#125; redux-saga1234import createSagaMiddleware from "redux-saga";import rootSaga from "./sagas";const sagaMiddleware = createSagaMiddleware();sagaMiddleware.run(rootSaga); 1234567891011121314151617181920212223242526272829303132333435363738// redux-saga/packages/core/src/internal/middleware.js// createSagaMiddleware 执行的就是这个函数export default function sagaMiddlewareFactory(&#123; context = &#123;&#125;, channel = stdChannel(), sagaMonitor, ...options&#125; = &#123;&#125;) &#123; let boundRunSaga; function sagaMiddleware(&#123; getState, dispatch &#125;) &#123; boundRunSaga = runSaga.bind(null, &#123; ...options, context, channel, dispatch, getState, sagaMonitor &#125;); return next =&gt; action =&gt; &#123; if (sagaMonitor &amp;&amp; sagaMonitor.actionDispatched) &#123; sagaMonitor.actionDispatched(action); &#125; const result = next(action); channel.put(action); return result; &#125;; &#125; // 这里会传入rootSaga，即项目中的所有的saga effect，也就是 generator sagaMiddleware.run = (...args) =&gt; &#123; return boundRunSaga(...args); &#125;; //... return sagaMiddleware;&#125; 123456789101112131415161718192021222324252627282930313233343536373839//redux-saga/packages/core/src/internal/runSaga.jsexport function runSaga( &#123; channel = stdChannel(), dispatch, getState, context = &#123;&#125;, sagaMonitor, effectMiddlewares, onError = logError &#125;, saga, ...args) &#123; // 这里的 saga 即是上面的 rootSaga，iterator 为生成器对象 const iterator = saga(...args); const effectId = nextSagaId(); //... return immediately(() =&gt; &#123; const task = proc( env, iterator, context, effectId, getMetaInfo(saga), /* isRoot */ true, undefined ); if (sagaMonitor) &#123; sagaMonitor.effectResolved(effectId, task); &#125; return task; &#125;);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//redux-saga/packages/core/src/internal/proc.jsexport default function proc(env, iterator, parentContext, parentEffectId, meta, isRoot, cont) &#123; //... next.cancel = noop const mainTask = &#123; meta, cancel: cancelMain, status: RUNNING &#125; const task = newTask(env, mainTask, parentContext, parentEffectId, meta, isRoot, cont) const executingContext = &#123; task, digestEffect, &#125; function cancelMain() &#123; if (mainTask.status === RUNNING) &#123; mainTask.status = CANCELLED next(TASK_CANCEL) &#125; &#125; if (cont) &#123; cont.cancel = task.cancel &#125; next() return task // 递归 iterator 生成器对象 function next(arg, isErr) &#123; try &#123; let result if (isErr) &#123; // 抛错误 result = iterator.throw(arg) sagaError.clear() &#125; else if (shouldCancel(arg)) &#123; mainTask.status = CANCELLED // 取消并返回迭代器对象 next.cancel() result = is.func(iterator.return) ? iterator.return(TASK_CANCEL) : &#123; done: true, value: TASK_CANCEL &#125; &#125; else if (shouldTerminate(arg)) &#123; // 中断并返回迭代器对象 result = is.func(iterator.return) ? iterator.return() : &#123; done: true &#125; &#125; else &#123; result = iterator.next(arg) &#125; // 如果迭代未结束则继续递归，并将返回值注入 if (!result.done) &#123; digestEffect(result.value, parentEffectId, next) &#125; // ... &#125; catch (error) &#123; if (mainTask.status === CANCELLED) &#123; throw error &#125; mainTask.status = ABORTED mainTask.cont(error, true) &#125; &#125;// ... // 递归调用 next，cb 即为传入的 next函数，effect 为返回值 function digestEffect(effect, parentEffectId, cb, label = '') &#123; const effectId = nextEffectId() //... let effectSettled function currCb(res, isErr) &#123; if (effectSettled) &#123; return &#125; effectSettled = true cb.cancel = noop //... // 继续递归 cb(res, isErr) &#125; //...&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[一次 webpack 分享小记]]></title>
    <url>%2Fpost-14%2F</url>
    <content type="text"><![CDATA[webpack 源码解析，针对从启动，编译的全流程及 plugin 和 loader 使用进行分析]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译]Javascript 中你需要知道的一切关于日期的事情]]></title>
    <url>%2Fpost-12%2F</url>
    <content type="text"><![CDATA[原文地址：Everything You Need to Know About Date in JavaScript原文作者：Zell Liew译者: charlie mei 在 Javascript 中日期很奇怪，它让我们紧张不安，以至于我们需要找到其他库(像 Date-fns 和 Moment)在我们需要使用日期和时间的时候(哈！)。 但是我们不总是需要使用库。如果你知道需要注意些什么，日期实际上相当简单。在本文中，我会引导你在 Javascript 中你需要知道的一切关于日期的事情。 首先，我们先承认时区的存在。 时区世界上有数以百计的时区。在 Javascript 中，我们只关心两个——本地时间和协调世界时(UTC)。 本地时间涉及你电脑所在的时区 UTC是现实中格林尼治标准时间(GMT)的代名词 在 Javascript 中(除了一个)几乎每个日期方法默认都会给你本地时间或者日期。假如你指定了 UTC 那么你只能得到 UTC。 有了这个，我们可以谈一下创建日期了。 创建日期你可以用new Date()创建日期。有四种可能的方式使用new Date()： 日期字符串 日期参数 时间戳 没有参数 日期字符串方法在日期字符串方法中，通过给new Date()传入日期字符串，你可以创建日期。 1new Date("1988-03-21"); 在写日期的时候，我们倾向于使用日期字符串。这很自然因为我们在生活中一直使用日期字符串。 如果我写下21-03-1988， 你推导出是 1988 年 3 月 21 日说没有问题的。是吗？但是如果你在 Javascript 里写21-03-1988，你会得到一个Invalid Date。 对于这个有充分的理由： 在世界的不同地方，我们翻译日期字符串的方式不同。例如11-06-2019不是2019年11月6日就是2019年6月11日。但是你不能确定我指的是哪一个，除非你指定我用的日期系统。 在 Javascript 中，如果你想使用日期字符串，你需要使用一个全世界都接受的格式。其中一个格式就是 ISO 8601 扩展格式。 12// ISO 8601 Extended format`YYYY-MM-DDTHH:mm:ss:sssZ`; 这是值所表示的意思： YYYY：4 位数字年份 MM：2 位数字月份(其中一月是 01，12 月是 12) DD：2 位数字日期(0 到 31) -： 日期分隔符 T：表明时间开始 HH：24 位数字小时(0 到 23) mm：分(0 到 59) ss：秒(0 到 59) sss：毫秒(0 到 999) :：时间分隔符 Z：如果Z存在，日期会被设置成 UTC。如果Z不存在，它会是本地时间(这仅适用于提供时间的情况) 如果你创建日期，小时，分，秒和毫秒是可选的。那么，如果你想创建 2019 年 6 月 11 日的时间，你可以这样写： 1new Date("2019-06-11"); 在这里要特别注意。使用日期字符串创建日期会一个巨大的问题。如果你console.log这个日期你会发现问题。 如果你生活的区域在 GMT 之后，你会得到一个 6 月 10 日的日期。 如果你生活的区域在 GMT 之前，你会得到一个 6 月 11 日的日期。 发生这个情况是因为日期字符串有一个奇怪的行为：如果你创建日期的时候没有指定时间，你得到的日期会被设置成 UTC。 在上面的脚本中，当你写入new Date(&quot;2019-06-11&quot;)，实际上你创建了一个11th June, 2019, 12am UTC日期。这是生活在 GMT 之前的人会得到10th June而不是11th June的原因。 如果你想用日期字符串创建当地时间的日期，你需要包括时间。当你包括时间的时候，你需要写入HH和mm的最小值(或者谷歌浏览器返回一个无效日期)。 1new Date("2019-06-11T00:00"); 和日期字符串有关的当地时间和 UTC 是一个可能的错误来源，这很难捕获。所以，我推荐你不要用日期字符串创建日期。 (顺便提一下，MDN 警告反对日期字符串方法，因为浏览器可以不同地解析日期字符串) 如果你想创建日期，使用参数或者时间戳。 用参数创建日期你可以传入七个参数去创建日期/时间。 Year：四位数字年份。 Month：一年中的月份(0-11)。月份从 0 开始索引。如果省略默认为 0。 Day：一月中的天数(1-31)。如果省略默认为 1. Hour：一天中的小时数(0-59)。如果省略默认为 0 Minutes：分钟(0-59)。如果省略默认为 0。 Seconds：秒(0-59)。如果省略默认为 0。 Milliseconds：毫秒(0-999)。如果省略默认为 0。 12// 11th June 2019, 5:23:59am, Local Timenew Date(2019, 5, 11, 5, 23, 59); 许多开发者(包括我自己)都避免使用参数方法，因为它看起来是复杂的。但实际上是相当简单。 尝试从左往右读数。从左到右你插入的值越来越小：年，月，日，时，分，秒，毫秒。 123456789new Date(2017, 3, 22, 5, 23, 50);// This date can be easily read if you follow the left-right formula.// Year: 2017,// Month: April (because month is zero-indexed)// Date: 22// Hours: 05// Minutes: 23// Seconds: 50 与日期有关的问题最多的部分是月份值是从 0 开始索引的，就像January === 0，February === 1，March === 2等等。 我们不知道为什么 Javascript 中月份从 0 开始索引，但是与其争论为什么一月份应该是 1(不是 0)，更好的是接受在 Javascript 中月份是从 0 开始索引。一旦你接受了这个事实，使用日期会变得相当简单。 下面是一些例子，会让你熟悉： 1234567891011// 21st March 1988, 12am, Local Time.new Date(1988, 2, 21);// 25th December 2019, 8am, Local Time.new Date(2019, 11, 25, 8);// 6th November 2023, 2:20am, Local Timenew Date(2023, 10, 6, 2, 20);// 11th June 2019, 5:23:59am, Local Timenew Date(2019, 5, 11, 5, 23, 59); 用参数创建的日期都是本地时间吗？ 那是用参数的好处之一——你不会在本地时间和 UTC 之间感到困惑。如果你真的需要 UTC，你可以用这个方式创建 UTC 日期。 12// 11th June 2019, 12am, UTC.new Date(Date.UTC(2019, 5, 11)) 用时间戳创建日期在 Javascript 中，时间戳是从 1970 年 1 月经过的毫秒数(1970 年 1 月也被称为 Unix 时间)。根据我的经验，你们很少使用时间戳创建时间。你们仅用时间戳在不同时间中进行比较(更多相关的在后面)。 12// 11th June 2019, 8am (in my Local Time, Singapore)new Date(1560211200000); 不用参数创建日期如果你不用参数创建日期，你会得到一个被设置成当前时间的日期(本地时间)。 1new Date(); 你可以从图像中看出是我写这篇文章的时间是新加坡的 5 月 25 日早上 11 时 19 分。 创建时间的总结 可以用new Date()创建时间 有四种可能的语法： 日期字符串 参数 时间戳 无参 永远不要用日期字符串方法创建日期。 最好用传参方法创建日期。 记住(并接受)Javascript 中月份是从 0 开始索引的。 接下来，我们讨论一下将日期转换成可读的字符串。 格式化日期大多数编程语言为你提供一个格式化工具去创建任意你要的日期格式。例如，在 PHP 里，你可以写date(&quot;d M Y&quot;)把日期转换成23 Jan 2019。 但是 Javascript 中没有容易的方式格式化日期。 原生日期对象附带七个格式化方法。每一个方法会给你提供一个特定的值(相当的没用)。 1const date = new Date(2019, 0, 23, 17, 23, 42); toString返回Wed Jan 23 2019 17:23:42 GMT+0800 (Singapore Standard Time)。 toDateString返回Wed Jan 23 2019。 toLocaleString返回23/01/2019, 17:23:42。 toLocaleDateString返回23/01/2019。 toGMTString返回Wed, 23 Jan 2019 09:23:42 GMT toUTCString返回Wed, 23 Jan 2019 09:23:42 GMT toISOString返回2019-01-23T09:23:42.079Z 如果你需要自定义格式，需要自己创建。 实现自定义日期格式假设你想要像Thu, 23 January 2019的格式。为了创建这个值，你需要知道(和使用)日期对象附带的日期方法。 你可以用这四个方法得到日期： getFullYear：根据本地时间得到四位数字年份 getMonth：根据本地时间得到一年中的月份(0-11)。月份从 0 开始索引 getDate：根据本地时间得到一月中的日期(1-31)。 getDay：根据本地时间得到一周中的星期几(0-6)。一周从周日(0)开始，周六(6)结束。 为了Thu, 23 January 2019创建23和2019很简单，我们可以使用getFullYear和getDate去获取。 123const d = new Date(2019, 0, 23);const year = d.getFullYear(); // 2019const date = d.getDate(); // 23 获取Thu和January困难。 为了获取January，你可以创建一个映射十二个月份到它们各自名字的对象。 1234567891011121314const months = &#123; 0: "January", 1: "February", 2: "March", 3: "April", 4: "May", 5: "June", 6: "July", 7: "August", 8: "September", 9: "October", 10: "November", 11: "December"&#125;; 既然月份是从 0 开始索引的，那么我们可以用数组而不是对象。它会产生同样的结果。 1234567891011121314const months = [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]; 为了获取January，我们需要： 用getMonth从日期中得到从 0 开始索引的月份 从months中获取月份名字 123const monthIndex = d.getMonth();const monthName = months[monthIndex];console.log(monthName); // January 精简版： 12const monthName = months(d.getMonth());console.log(monthName); // January 你可以以同样的方式获取Thu。这次，我们需要一个包含一周七天的数组。 1const days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]; 然后你： 用getDay获取dayIndex 用dayIndex去获取dayName 12const dayIndex = d.getDay();const dayName = days[dayIndex]; // Thu 精简版： 1const dayName = days[d.getDay()]; // Thu 然后，你把你创建的变量组合起来，就可以得到格式化了的字符串。 12const formatted = `$&#123;dayName&#125;, $&#123;date&#125; $&#123;monthName&#125; $&#123;year&#125;`;console.log(formatted); // Thu, 23 January 2019 是的，它是乏味的。但是一旦掌握它，这并非不可能。 如果你曾经需要创建一个自定义的格式化时间，你可以使用以下方法： getHours：根据本地时间获取小时(0-23) getMinutes：根据本地时间获取分钟(0-59) getSeconds：根据本地时间获取秒(0-59) getMilliseconds：根据本地时间获取毫秒(0-999) 下一步，我们讨论一下日期比较。 日期比较如果你想知道一个日期是否在另一个之前或者之后，你可以直接用&gt;，&lt;，&gt;=和&lt;=对它们进行比较。 1234const earlier = new Date(2019, 0, 26)const later = new Date(2019, 0, 27)console.log(earlier &lt; later) // true 更困难的是如果你想检测两个日期是否是完全相同的时间。你不能用==或者===进行比较。 12345const a = new Date(2019, 0, 26);const b = new Date(2019, 0, 26);console.log(a == b); // falseconsole.log(a === b); // false 为了检测两个日期是否是相同的时间，你可以用getTime检测它们的时间戳。 1234567const isSameTime = (a, b) =&gt; &#123; return a.getTime() === b.getTime();&#125;;const a = new Date(2019, 0, 26);const b = new Date(2019, 0, 26);console.log(isSameTime(a, b)); // true 如果你想检测两个日期是否是相同的天，你可以检测它们getFullYear，getMonth和getDate返回的值。 1234567891011const isSameDay = (a, b) =&gt; &#123; return ( a.getFullYear() === b.getFullYear() &amp;&amp; a.getMonth() === b.getMonth() &amp;&amp; a.getDate() === b.getDate() );&#125;;const a = new Date(2019, 0, 26, 10); // 26 Jan 2019, 10amconst b = new Date(2019, 0, 26, 12); // 26 Jan 2019, 12pmconsole.log(isSameDay(a, b)); // true 还有最后一件事我们得涵盖的。 从另一个日期获取日期有两个可能的你想从另一个日期获取日期的脚本。 从另一个日期设置特定的日期/时间值 从另一个日期增/减一个增量 设置一个特定的日期/时间你可以使用这些方法从另一个日期设置日期/时间： setFullYear：在本地时间设置 4 位数年份 setMonth：在本地时间设置月份 setDate：在本地时间设置天数 setHours：在本地时间设置小时 setMinutes：在本地时间设置分钟 setSeconds：在本地时间设置秒 setMilliseconds：在本地时间设置毫秒 例如，如果你想把日期设置成本月中的第 15 天，你可以用setDate(15)。 1234const d = new Date(2019, 0, 10);d.setDate(15);console.log(d); // 15 January 2019 如果你想把月份设置成六月，你可以用setMonth。(记住，Javascript 中月份是从 0 开始索引的！) 1234const d = new Date(2019, 0, 10);d.setMonth(5);console.log(d); // 10 June 2019 注意：上面的 setter 方法会改变原始时间对象。实践中，我们不应该改变对象。相反我们应该在新的时间对象上执行这些操作。 123456const d = new Date(2019, 0, 10);const newDate = new Date(d);newDate.setMonth(5);console.log(d); // 10 January 2019console.log(newDate); // 10 June 2019 从另一个日期增/减一个增量增量是一个变化。从另一个日期加/减一个增量，我意思是：你想从另一个日期获取一个 X 日期。可能是 X 年，X 月，x 日等等。 为了获取增量，你需要知道当前日期的值。你可以用这些方法获取它： getFullYear：根据本地时间得到四位数字年份 getMonth：根据本地时间得到一年中的月份(0-11)。月份从 0 开始索引 getDate：根据本地时间得到一月中的日期(1-31)。 getDay：根据本地时间得到一周中的星期几(0-6)。一周从周日(0)开始，周六(6)结束。 getHours：根据本地时间获取小时(0-23) getMinutes：根据本地时间获取分钟(0-59) getSeconds：根据本地时间获取秒(0-59) getMilliseconds：根据本地时间获取毫秒(0-999) 有两个常见方法增/减一个增量。第一个在 Stack Overflow 更受欢迎。它简洁，但很难掌握。第二个方法更加冗长，但很容易理解。 我们来看看这两种方法。 假设你想获得一个三天后的日期。在这个例子中，我们也假定今天是 2019 年 3 月 28 日。(当我们使用固定日期时这更容易解释)。 12// Assumes today is 28 March 2019const today = new Date(2019, 2, 28); 首先，我们创建一个新的日期对象(这样我们没有改变原始日期对象) 1const finalDate = new Date(today); 接着，我们需要知道我们想改变的值。既然我们打算改变天数，我们可以用getDate获取天。 1const currentDate = today.getDate(); 我们想要一个三天后的日期。我们将增加增量(3)到当前日期。 1finalDate.setDate(currentDate + 3); 设置方式的完整的代码： 12345const today = new Date(2019, 2, 28);const finalDate = new Date(today);finalDate.setDate(today.getDate() + 3);console.log(finalDate); // 31 March 2019 现在我们使用getFullYear，getMonth，getDate和其他 getter 方法直到我们达到我们想要改变的值的类型。然后，我们用new Date()创建最终日期。 1234567891011const today = new Date(2019, 2, 28);// Getting required valuesconst year = today.getFullYear();const month = today.getMonh();const day = today.getDate();// Creating a new Date (with the delta)const finalDate = new Date(year, month, day + 3);console.log(finalDate); // 31 March 2019 两种方法都有效。选一种并坚持下去。 自动日期校正如果你提供一个超过它可接受范围的值给 Date，Javascript 会自动为你重新计算日期。 这是一个例子。让我们假设我们设置日期为 2019 年 3 月 33 日。(日历上没有 3 月 33 日)。这种情况下，Javascript 自动调整 3 月 33 日到 4 月 2 日。 12// 33rd March =&gt; 2nd Aprilnew Date(2019, 2, 33) 这意味着你不需要担心计算分钟，小时，天，月等等。当创建一个增量，Javascript 自动为你处理它。 12// 33rd March =&gt; 2nd Aprilnew Date(2019, 2, 30 + 3) 以上就是你需要知道的关于 Javascript 原生日期对象的所有东西。]]></content>
      <tags>
        <tag>前端</tag>
        <tag>frontend</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谷歌扩展开发小记]]></title>
    <url>%2Fpost-11%2F</url>
    <content type="text"><![CDATA[尝试开发谷歌浏览器扩展，medium 免费阅读器，目前主要是需要对请求进行拦截，修改， [github 仓库]https://github.com/meijintao233/medium-reader-extension 将一些常用的 API 记录如下： manifest.json主要是设置一些位置，展示信息，类似微信小程序的配置 app.json。 Permissions: 设置一些需要获取权限的功能 browser_action: 设置 icon、界面等，浏览器级的扩展，界面 html 和页面的 html 是两个隔离的环境 page_action: 设置 icon、界面等，页面级的扩展，界面 html 和页面的 html 是两个隔离的环境 background: 设置 js 脚本等 content_script前台脚本，不可跨域，会注入到页面中，可以操作当前页面的 dom 等 background_script后台脚本，可跨域，一般会需要从 content_script 中发送信息过来，再发跨域请求 page_action页面级的扩展，可控制显隐，特定页面显示 可绑定 onClick 事件，在点击扩展图标时执行，但是如果有 html 界面则该事件不生效 browser_action浏览器级扩展 可绑定 onClick 事件，在点击扩展图标时执行，但是如果有 html 界面则该事件不生效 chrome api tabs get 获取标签页详情 sendMessage 方法 向指定标签页中的 content_script 发送消息 excuteScript 可以注入 js 脚本 参数是 (tabid,{file:[]}) connect 用于所属扩展与 content_scirpt 的连接进行通信 create 创建新标签页 duplicate 复制标签页 query 获取标签页 highlight 标签页高亮 update 更新标签页属性 move 移动标签页 根据 index 从 0 开始计数 remove 关闭标签页 storage sync 对浏览器同步功能生效 local 对本机生效 get set clear remove getBytesInUse 获取使用空间 onChange 发生变化触发 runtime 相当于运行时功能 getBackgroundPage 获取该扩展的 background 界面的 window 对象，并将对象以回调形式传入 getManifest 获取 manifest.json 信息 getUrl 将相对地址转换成绝对地址 reload 重新加载扩展 connect 用于 content_scirpt 连接所属扩展进行通信 getPlatformInfo 获取平台信息 sendMessage 方法 extensionId 参数 向其他扩展发送信息 onInstalled 扩展安装成功或更新触发 onSuspend 页面卸载前触发 onConnect 从其他扩展或者 content_script 发起连接时触发 onMessage 从其他扩展或者 content_script 接收消息时触发 extension getViews 获取该扩展界面下的所有 window 对象，包括 background 界面 getBackgroundPage 获取该扩展的 background 界面的 window 对象 getUrl 将相对地址转换成绝对地址 通信、请求拦截 Web request 有 onBeforeSendHeaders，onHeadersReceived 支持修改 header 信息，onCompleted 表示请求完成等事件 接受三个参数，分别是回调（回调中能获取请求的信息），filter 数组（type，urls (使用匹配模式)，），额外页面信息（blocking,extraheaders,requestheader,responseheaders 等），blocking 模式才能对请求进行修改，需要 return blocking 对象 更多 API]]></content>
      <tags>
        <tag>前端</tag>
        <tag>谷歌扩展</tag>
        <tag>frontend</tag>
        <tag>chrome extension</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译]JavaScript箭头函数中的不规则]]></title>
    <url>%2Fpost-10%2F</url>
    <content type="text"><![CDATA[原文地址：Anomalies in JavaScript arrow functions原文作者：Glad Chinda译者: charlie mei 介绍就我而言，我认为箭头函数是 Javascript 语言在 ES6 规范中最棒的语法补充之一——我的意见，顺便提一下。我知道它以后几乎每天都要使用它们，我猜测这对于大多数 Javascript 开发者也是这样的。 箭头函数在很多方面也可以像常规的函数一样使用。然而，它们通常用于在需要匿名函数语句的地方——例如，回调函数。 下面的例子展示了一个箭头函数是怎样被用作回调函数的，特别是数组方法如map()，filter()，reduce()，sort()等等。 1234567const scores = [ /* ...some scores here... */];const maxScore = Math.max(...scores);// Arrow Function as .map() callbackscores.map((score) =&gt; +(score / maxScore).toFixed(2)); 一眼过去，箭头函数可能看起来像可以被用于或者定义在每个常规函数也能这样的地方，但事实并不是这样的。出于非常好的原因，箭头函数并不是恰好表现得像常规函数一样。也许箭头函数可以被认为是不规则的 Javascript 函数。 尽管箭头函数有一个相当简单的语法，这不是本文的重点。本文的目标是揭示箭头函数不同于常规函数的主要行为方式以及怎样将这些知识用于开发者的优势。 请注意：在本文中，我会用常规函数或者常规 Javascript 函数的术语表示传统的 Javascript 函数语句或者使用 function 关键字定义的表达式。 TL;DR 箭头函数没有重复的命名参数，无论是在严格或者非严格模式。 箭头函数没有arguments绑定，然而，它们可以访问最接近的非箭头父函数的 arguments 对象。命名和剩余参数非常依赖于捕获的传递给箭头函数的参数。 箭头函数不能用作构造函数。于是它们不能被new关键字调用。因此箭头函数上不存在原型属性。 箭头函数里this的值在整个函数的生命周期中保持一样而且总是受到最接近的非箭头父函数的this的值约束 命名函数参数Javascript 中的函数通常使用命名参数定义。命名参数是用来根据位置将参数映射到函数作用域里的局部变量中 考虑以下的 Javascript 函数： 12345678910111213function logParams(first, second, third) &#123; console.log(first, second, third);&#125;// first =&gt; 'Hello'// second =&gt; 'World'// third =&gt; '!!!'logParams("Hello", "World", "!!!"); // "Hello" "World" "!!!"// first =&gt; &#123; o: 3 &#125;// second =&gt; [ 1, 2, 3 ]// third =&gt; undefinedlogParams(&#123; o: 3 &#125;, [1, 2, 3]); // &#123;o: 3&#125; [1, 2, 3] logParams()函数定义了三个命名参数:first，second和third。命名参数会基于位置映射到被调用函数的参数中。如果命名参数比传递给函数的参数还多，剩下的参数值就是undefined。 关于命名参数，常规 Javascript 函数在非严格模式下表现了一个奇怪的行为。在非严格模式中，常规 Javascript 函数允许重复的命名参数。以下的代码段展示了这种行为的结果： 12345678910111213function logParams(first, second, first) &#123; console.log(first, second);&#125;// first =&gt; 'Hello'// second =&gt; 'World'// first =&gt; '!!!'logParams("Hello", "World", "!!!"); // "!!!" "World"// first =&gt; &#123; o: 3 &#125;// second =&gt; [ 1, 2, 3 ]// first =&gt; undefinedlogParams(&#123; o: 3 &#125;, [1, 2, 3]); // undefined [1, 2, 3] 正如我们所看到的，first参数重复了。因此，它被映射到了传给函数调用的第三个参数的值，完全覆盖了传入的第一个参数。这不是一个有利的行为。 好消息是这个这个行为在严格模式下不被允许。在严格模式下定义一个有重复参数的函数会抛出一个语法错误的异常，这表明不允许重复参数。 12345// Throws an error because of duplicate parameters (Strict mode)function logParams (first, second, first) &#123; "use strict"; console.log(first, second);&#125; 箭头函数怎样对待重复参数？现在这有关于箭头函数的描述： Unlike regular functions, arrow functions do not allow duplicate parameters, wether in strict or non-strict mode. Duplicate parameters will cause a Syntax Errorto be thrown. 1234// Always throws a syntax errorconst logParams = (first, second, first) =&gt; &#123; console.log(first, second);&#125; 函数重载函数重载是定义函数的能力，这样函数就可以被不同的调用签名(形态或者参数的数量)调用。好消息是 Javascript 函数的参数绑定让这个成为可能。 一开始，考虑这非常简单的重载函数，它计算传递给它的任意数量参数平均值： 1234567891011121314151617function average() &#123; // the number of arguments passed const length = arguments.length; if (length == 0) return 0; // convert the arguments to a proper array of numbers const numbers = Array.prototype.slice.call(arguments); // a reducer function to sum up array items const sumReduceFn = function(a, b) &#123; return a + Number(b); &#125;; // return the sum of array items divided by the number of items return numbers.reduce(sumReduceFn, 0) / length;&#125; 我尝试让函数定义尽可能详细，这样它的行为就可以清楚地理解。这个函数可以用任意数量的参数调用，从 0 到函数可以取到的最大数量的参数——那应该是 255。 这是其中一些调用avarage()函数的结果： 1234average(); // 0average("3o", 4, 5); // NaNaverage("1", 2, "3", 4, "5", 6, 7, 8, 9, 10); // 5.5average(1.75, 2.25, 3.5, 4.125, 5.875); // 3.5 现在尝试用箭头函数的语法复制avarage()函数。我的意思是，那是一件多难的事情？首先猜猜——你所有要做的在这： 123456789101112const average = () =&gt; &#123; const length = arguments.length; if (length == 0) return 0; const numbers = Array.prototype.slice.call(arguments); const sumReduceFn = function(a, b) &#123; return a + Number(b); &#125;; return numbers.reduce(sumReduceFn, 0) / length;&#125;; 当你现在测试这个函数的时候，你会意识到它抛出了一个Reference Error引用错误，猜猜是什么？在所有可能的原因中，抱怨到arguments没定义。 你有什么问题？现在这有一些其他的关于箭头函数的东西： Unlike regular functions, the arguments binding does not exist for arrow functions. However, they have access to the arguments object of a non-arrow parent function. 基于这个理解，你可以修改average()函数，让它成为一个常规函数，其返回结果是立即调用的嵌套箭头函数，这个箭头函数可以访问父函数的arguments。这看起来像是这样的： 1234567891011121314function average() &#123; return (() =&gt; &#123; const length = arguments.length; if (length == 0) return 0; const numbers = Array.prototype.slice.call(arguments); const sumReduceFn = function(a, b) &#123; return a + Number(b); &#125;; return numbers.reduce(sumReduceFn, 0) / length; &#125;)();&#125; 显而易见，这解决了你arguments对象未定义的难题。然而，你得使用一个嵌套在常规函数中的箭头函数，对于像这样的简单函数来说，这似乎是不必要的。 你可以做得不同吗？既然这里访问arguments对象是一个显而易见的困难，有其他选择吗？答案是有。跟 ES6 的剩余参数打招呼。 使用 ES6 的剩余参数，你可以得到一个数组，它能访问所有或者部分传递给函数的参数。这适用于所有函数，无论是常规函数还是箭头函数。这是它的样子： 12345678const average = (...args) =&gt; &#123; if (args.length == 0) return 0; const sumReduceFn = function(a, b) &#123; return a + Number(b); &#125;; return args.reduce(sumReduceFn, 0) / args.length;&#125;; 哇！剩余参数的援救——你最终找到了一个优雅的解决方法，用箭头函数实现了average()函数。 这有一些针对依赖剩余参数访问函数参数的注意事项： 剩余参数和函数里的内部arguments对象不同。剩余参数是真实的函数参数，然而arguments对象是一个受到函数作用域约束的内部对象。 一个函数只能有一个剩余参数，而且它必须总是函数的最后一个参数。这意味着一个函数可以有多个命名参数和一个剩余参数的结合。 剩余参数，如果存在，可能无法捕获所有的函数参数，尤其是它和命名参数一起使用的时候。然而，当它是唯一函数参数时，它可以捕获所有的参数。另一方面，函数的 arguments对象总是能捕获所有的函数参数。 剩余参数指向一个数组对象，它包含了所有捕获的函数参数，而arguments对象指向一个类数组对象，它包含了所有的函数参数。 在你继续之前，考虑另一个简单的重载函数，它将数字从一个数字转换成另一个。这个函数可以被一个到三个参数调用。然而，当它被两个或更少的参数调用时，在执行时，它会交换第二个和第三个参数。 这看起来像一个常规函数： 1234567function baseConvert(num, fromRadix = 10, toRadix = 10) &#123; if (arguments.length &lt; 3) &#123; // swap variables using array destructuring [toRadix, fromRadix] = [fromRadix, toRadix]; &#125; return parseInt(num, fromRadix).toString(toRadix);&#125; 以下是其中一些baseConvert()函数的调用： 12345678// num =&gt; 123, fromRadix =&gt; 10, toRadix =&gt; 10console.log(baseConvert(123)); // "123"// num =&gt; 255, fromRadix =&gt; 10, toRadix =&gt; 2console.log(baseConvert(255, 2)); // "11111111"// num =&gt; 'ff', fromRadix =&gt; 16, toRadix =&gt; 8console.log(baseConvert("ff", 16, 8)); // "377" 基于你所知道的关于箭头函数没有它自己的arguments绑定，你可以用箭头函数语法重写baseConvert() 函数，如下： 123456789101112const baseConvert = (num, ...args) =&gt; &#123; // destructure the `args` array and // set the `fromRadix` and `toRadix` local variables let [fromRadix = 10, toRadix = 10] = args; if (args.length &lt; 2) &#123; // swap variables using array destructuring [toRadix, fromRadix] = [fromRadix, toRadix]; &#125; return parseInt(num, fromRadix).toString(toRadix);&#125;; 注意到之前的我用 ES6 数组结构语法用数组元素设置本地变量的代码片段，也可以交换变量。你可以学到更多关于结构的内容，通过阅读这个指南：[ES6 Destructuring: The Complete Guide]。 构造函数一个常规 Javascript 函数能被new关键字调用，这样函数表现得会像一个创造新的实例对象的构造类。 这是一个简单被用作构造器的函数例子： 1234567891011121314151617181920function Square(length = 10) &#123; this.length = parseInt(length) || 10; this.getArea = function() &#123; return Math.pow(this.length, 2); &#125;; this.getPerimeter = function() &#123; return 4 * this.length; &#125;;&#125;const square = new Square();console.log(square.length); // 10console.log(square.getArea()); // 100console.log(square.getPerimeter()); // 40console.log(typeof square); // "object"console.log(square instanceof Square); // true 当一个常规 Javascript 函数被new关键字调用，函数内部的[[Construct]]方法会被调用来创建一个新的实例对象和分配内存。在那之后，函数体正常执行，将this映射到刚被创建的实例对象上。最后，函数隐式的返回this(刚被创建的实例对象)，除了在函数定义中指定了不同的返回值。 所有常规的 Javascript 函数都有prototype属性。函数的prototype属性是一个对象，其中包含了在所有被用作构造器的函数所创建的实例对象中共享的属性和方法。 刚开始，prototype属性是一个空对象，constructor属性指向该函数。然而，它可以用属性和方法进行扩充，这便于为该函数作为构造函数创建的对象添加更多功能。 这是对先前的Square函数的一个轻微的改动，在函数的原型上定义方法而不是在构造函数里。 1234567891011121314151617181920function Square(length = 10) &#123; this.length = parseInt(length) || 10;&#125;Square.prototype.getArea = function() &#123; return Math.pow(this.length, 2);&#125;;Square.prototype.getPerimeter = function() &#123; return 4 * this.length;&#125;;const square = new Square();console.log(square.length); // 10console.log(square.getArea()); // 100console.log(square.getPerimeter()); // 40console.log(typeof square); // "object"console.log(square instanceof Square); // true 正如你所说的，所有事情仍然和预想的一样。实际上，这有一点秘密：ES6 的类在背后做了和以上代码片段类似的一些事情——它们是简单的语法糖。 那么箭头函数怎么样？它们也和常规的 Javascript 函数那样共享这个行为吗？答案是否。现在在这里又有一些其他的关于箭头函数的东西： Unlike regular functions, arrow functions can never be called with the new keyword because they do not have the [[Construct]] method. As such, the prototypeproperty also does not exist for arrow functions. 令人伤心的是，这是真的。箭头函数不能用作构造器。它们不能被new调用。那样做会抛出一个错误，表明该函数不是一个构造器。 结果是，例如new.target的绑定，存在于可以被构造器调用的函数中，这并不在箭头函数里。相反，它们使用最接近的非箭头父函数的new.target值。 因为箭头函数不能被new关键字调用，它们确实也不需要有原型。于是prototype属性不在箭头函数中。 既然箭头函数的prototype是undefined，那试图用属性和方法扩充它或者访问它上面的属性都会抛出错误。 12345678910111213const Square = (length = 10) =&gt; &#123; this.length = parseInt(length) || 10;&#125;;// throws an errorconst square = new Square(5);// throws an errorSquare.prototype.getArea = function() &#123; return Math.pow(this.length, 2);&#125;;console.log(Square.prototype); // undefined this是什么？现在如果你已经写了一段时间 Javascript 程序，你会注意到每个 Javascript 函数的调用都关联着一个调用上下文，依赖于函数是怎样或者在哪被触发的。 函数中this的值非常依赖于函数调用上下文触发的时间，这通常将 Javascript 开发者置于一个境地，他们得问自己一个著名的问题：this的值是什么？ 这是一个this值的总结，指向不同情况的函数调用： 使用new关键字调用：this指向由内部[[Construct]]函数方法创建的新实例对象。this(新创建的实例对象)通常默认返回，除非在函数定义时明确指定了不同的返回值。 不使用new关键字直接调用：在非严格模式，this指向 Javascript 宿主环境的全局对象(在 web 浏览器中，通常是window对象)。然而，在严格模式下，this的值是undefined；因此，尝试访问或者设置属性在this上会抛出错误。 间接使用绑定对象调用：Function.prototype对象提供了三个方法让函数在被调用的时候绑定任意一个对象成为可能，方法名是：call()，apply()和bind()。用这些方法调用函数，this会指向指定的绑定对象。 作为对象的方法调用：函数(方法)被调用的时候，this指向调用的对象，无论这个方法是否定义在对象自身的属性上或者在对象的原型链中被解析出来。 作为事件处理器被调用：对于用在 DOM 事件监听中的常规 Javascript 函数来说，this在事件触发的时候指向目标对象，DOM 元素，document或者window。 开始，考虑这个绑定在表单提交按钮的简单的点击事件监听 Javascript 函数： 1234567891011121314function processFormData(evt) &#123; evt.preventDefault(); // get the parent form of the submit button const form = this.closest("form"); // extract the form data, action and method const data = new FormData(form); const &#123; action: url, method &#125; = form; // send the form data to the server via some AJAX request // you can use Fetch API or jQuery Ajax or native XHR&#125;button.addEventListener("click", processFormData, false); 如果你尝试这个代码，你会看到所有东西正确运作。像你先前看到的，在事件监听函数中，this的值是触发点击事件的 DOM 元素，在本例中是button。 因此，可以使用指向提交按钮的父表单： 1this.closest("form"); 这时，你用了一个常规 Javascript 函数作为事件处理器。如果你使用全新的箭头函数语法更改函数定义，会发生什么呢？ 123456789101112const processFormData = (evt) =&gt; &#123; evt.preventDefault(); const form = this.closest("form"); const data = new FormData(form); const &#123; action: url, method &#125; = form; // send the form data to the server via some AJAX request // you can use Fetch API or jQuery Ajax or native XHR&#125;;button.addEventListener("click", processFormData, false); 如果你现在尝试这个，你会注意到你得到了错误。从表面看，this的值似乎不是你所期望的。因为一些原因，this的值没有指向button元素——反而指向了全局window对象。 你可以做什么去修复this绑定？你还记得Function.prototype.bind()？你可以在为提交按钮设置事件监听的时候，用那强制把this的值绑定在button元素上。这是： 12// Bind the event listener function (`processFormData`) to the `button` elementbutton.addEventListener("click", processFormData.bind(button), false); 噢！这似乎不是你想要的修复。this仍然指向全局window对象。这是箭头函数特有的问题吗？这意味着箭头函数不能用在依赖于this的事件处理器中吗？ 你有什么问题？现在，这是关于箭头函数的最后一件事： 不像常规函数，箭头函数没有它们自己的this绑定。this的值从它们最接近的非父箭头函数中或者全局对象中解析出来。 这解释了为什么在事件监听中箭头函数的this值指向全局 window 对象(global 对象)了。因为它没有嵌套在父函数中，它会使用最接近的父作用域的this值，这里是全局作用域。 然而，这解释不了为什么你不能用bind()将事件监听箭头函数绑定在button元素上。这有一个解释： 不像常规函数，箭头函数里this的值保持不变而且在它们的生命周期中不会被改变，与触发上下文无关。 箭头函数的这个行为让 Javascript 引擎优化它们成为可能，因为函数绑定可以预先确定。 考虑一个稍微不同的脚本，事件处理器使用对象方法中的常规函数来定义而且依赖于相同对象的另一个方法： 12345678910111213141516171819202122(&#123; _sortByFileSize: function(filelist) &#123; const files = Array.from(filelist).sort(function(a, b) &#123; return a.size - b.size; &#125;); return files.map(function(file) &#123; return file.name; &#125;); &#125;, init: function(input) &#123; input.addEventListener( "change", function(evt) &#123; const files = evt.target.files; console.log(this._sortByFileSize(files)); &#125;, false ); &#125;&#125;.init(document.getElementById("file-input"))); 这是一个有_sortByFileSize()方法和init()方法的一次性对象字面量，它会立即触发。init()方法接受一个文件input元素和为这个输入元素设置了一个 change 事件处理器，根据上传文件的大小排序并且记录它们到浏览器的控制台上。 如果你测试这个代码，你会明白在你选择文件上传的时候，文件列表不会被排序和记录到控制台上；相反，控制台会抛出错误。问题来自这一行： 1console.log(this._sortByFileSize(files)); 在事件监听函数中，this指向触发事件的 DOM 元素，在本例中是input元素；于是，this._sortByFileSize是 undefined。 为了解决这个问题，你需要绑定事件监听中的this到包含这个方法的外部对象中，这样你就能够触发this._sortByFileSize()。这里你可以用bind()，如下： 123456init: function (input) &#123; input.addEventListener('change', (function (evt) &#123; const files = evt.target.files; console.log(this._sortByFileSize(files)); &#125;).bind(this), false);&#125; 现在所有事情都如预想的工作。这里不用bind()，你可以简单的把常规的事件监听函数替换成箭头函数。箭头函数会使用父init()方法中的this值，这方法是必须的对象。 123456init: function (input) &#123; input.addEventListener('change', evt =&gt; &#123; const files = evt.target.files; console.log(this._sortByFileSize(files)); &#125;, false);&#125; 在你继续之前，再考虑一个脚本。假设你有一个简单的作为构造器触发的计数器函数，以秒为单位创建倒计时计数器。它使用了setInterval()一直倒计时，直到限定时间过去或者 interval 被清除。如下： 1234567891011121314function Timer(seconds = 60) &#123; this.seconds = parseInt(seconds) || 60; console.log(this.seconds); this.interval = setInterval(function() &#123; console.log(--this.seconds); if (this.seconds == 0) &#123; this.interval &amp;&amp; clearInterval(this.interval); &#125; &#125;, 1000);&#125;const timer = new Timer(30); 如果你执行代码，你会看到倒计时计时器似乎坏了。它不断在控制台上记录NaN。 问题是在回调函数中传递的setInterval()，this指向全局window对象而不是在Timer函数作用域中新创建的instance对象。于是，this.seconds和this.interval都是undefined。 像之前为了修复它，你可以用bind()将setInterval()回调函数中的this值绑定到新创建的实例对象上，如下： 123456789101112131415function Timer(seconds = 60) &#123; this.seconds = parseInt(seconds) || 60; console.log(this.seconds); this.interval = setInterval( function() &#123; console.log(--this.seconds); if (this.seconds == 0) &#123; this.interval &amp;&amp; clearInterval(this.interval); &#125; &#125;.bind(this), 1000 );&#125; 或者更好的是，你可以用箭头函数替换setInterval()中的常规回调函数，这样你就能用最接近的非箭头父函数的this值，本例中是Timer。 123456789101112function Timer(seconds = 60) &#123; this.seconds = parseInt(seconds) || 60; console.log(this.seconds); this.interval = setInterval(() =&gt; &#123; console.log(--this.seconds); if (this.seconds == 0) &#123; this.interval &amp;&amp; clearInterval(this.interval); &#125; &#125;, 1000);&#125; 现在你完全理解了箭头函数怎样处理this关键字，重要的是要注意箭头函数在这些例子中并不是完美的，例如在你需要保存this值的地方，你要定义一个对象方法并且需要引用该对象的时候或者用方法扩充函数的原型并且在方法中需要引用到该目标对象的时候。 不存在的绑定在本文中，你已经知道了几个绑定，它们可以在常规函数中应用，但不存在于箭头函数中。相反，箭头函数从最接近的非箭头父函数中得到这样绑定的值。 综上，这是箭头函数中不存在的绑定列表： arguments：函数调用时传递的参数列表。 new.target：对使用new关键字作为构造器调用的函数引用。 super：函数所属对象原型的引用，倘若它被定义为简洁的对象方法。 this： 函数触发上下文对象的引用 结论嗨，我真的很高兴，你到了本文的结尾，尽管阅读时间很长，并且我非常希望你在阅读中学到一到两样东西。感谢你的时间。 Javascript 箭头函数真的很棒，有这些酷的特点(我们在本文中已经回顾的)，这会让 Javascript 引擎更容易优化它们，这是常规 Javascript 函数不具备的方式。 在我看来，我会说你应该尽可能多的使用箭头函数——除了这些你用不了的情况。]]></content>
      <tags>
        <tag>前端</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式浅析]]></title>
    <url>%2Fpost-9%2F</url>
    <content type="text"><![CDATA[介绍正则表达式在编程中得到广泛的使用，我们可以很方便的通过正则表达式筛选匹配出我们所需要的内容，进而对这些内容进行修改和替换。相比于静态文本匹配，使用正则表达式能带来更多的灵活性，适用的场景也更多。 JS引擎中处理正则使用的是NFA自动机，其特点是执行慢，但是编译快，适合JS这种动态解释型语言，使用过程中要注意正则匹配过程中的回溯，容易造成性能问题。 12reg: /te&#123;1,3&#125;st/gstring: teest 首先，正则的第一个字符，会与字符串的第一个字符比对，匹配后指针后移到第二个字符e，匹配后，继续后移遇到{1,3}操作符，因为正则匹配是贪婪模式，这时字符串指针会继续后移，遇到第二个e，指针继续后移，发现s和正则e不匹，这时发生回溯，字符串和正则指针回到前一个状态，接着正则指针指向下一个字符s，字符串指针指向下一个字符s，匹配成功，然后继续后移，t也匹配成功，最终完成整个正则匹配过程，匹配结果为teest。从上面可以看出，回溯等于是把之前的操作推倒重来，在设计正则规则的时候需要尽量减少发生回溯的可能。 用法我们使用正则的时候先定义匹配规则，生成匹配规则有两种形式，分别是字面量和构造函数的方式，然后还可以加上正则的flag值，分别是g表示全局搜索，i表示忽略大小写，m表示多行搜索 12const reg = /abc/giconst reg1 = new RegExp('abc'，'gi') 正则中还使用了一些特殊字符，常用的有： 12345678910111213141516171819202122232425\ 转义字符^ 输入的开始$ 输入的结束* 0次或多次+ 1次或多次? 0次或1次，跟在量词*、+等后面表示非贪婪模式. 除换行符外的任意字符x|y x或y&#123;n&#125; n次&#123;n,&#125; n次以上&#123;n,m&#125; n次到m次之间(x) 子字符串，结果将会被存储起来,可捕获到,匹配时\1，\2等表示，替换时则是 $1,$2等[xyz] 字符xyz的集合 [^xyz] 非字符xyzy(?=x) 后面是x的y,不捕获括号中的字符y(?!x) 后面不是x的y,不捕获括号中的字符(?&lt;=x)y 前面是x的y，不捕获括号中的字符(?&lt;!x)y 前面不是x的y，不捕获括号中的字符\d 表示数字\D 表示非数字，大写表示[^\d],以下同理\w 表示字母、数字或者下划线\s 表示空白字符\b 表示单词边界的位置，单词边界一般指\w所定义的字符所组成的子串其中 ^，$，(?=x)，(?!x)，(?&lt;=x)，(?&lt;!x)，\b，\B只匹配位置，而不是字符 与此相关的正则表达式方法有 12345678910111213141516171819202122exec// const reg = /t(e+)st/g // const result = reg.exec('teeesteeaxcz')//["teeest", "eee", index: 0, input: "teeesteeaxcz", groups: undefined]//exec函数返回的是完整的匹配信息，匹配成功会返回一个数组，数组由匹配字符串以及子字符串构成，即括号中匹配的内容，除此之外还会有，index表示匹配成功的起始索引信息，input表示输入的字符串，匹配失败返回nulltest// const reg = /t(e+)st/g // const result = reg.test('teeesteeaxcz')// exec函数返回判断性信息，匹配成功返回truesearch// const str = 'teeesteeaxcz'// const result = str.search(/t(e+)st/g)// search函数返回匹配成功的位置索引信息match// const str = 'teeesteeaxcz'// const result = str.match(/t(e+)st/g)// match函数返回匹配成功的字符串的数组replace//const re = /(\w+)\s(\w+)/;//const str = "charlie james";//str.replace(re, "$2, $1"); //james charlie// replace函数返回匹配成功并替换后的新字符串，其中可以使用$n作为括号匹配的变量，如果第二个传入的是函数，那么该函数会被注入多个参数，分别是(match,$1,$2...,index,input),match表示匹配字符串，$n表示括号匹配数，index表示匹配成功的起始索引，input表示输入，函数的返回值则是替换后的字符串 示例将数字表示成千位分隔 123const reg = /(?&lt;!\.\d+)\B(?=(?:\d&#123;3&#125;)+\b)/g //123456789-&gt;123,456,789,12345.6789-&gt;12,345.6789// 该正则规则的意思是，在需要插入的非单词边界位置，前面没有.和任意数字，即小数点后面的不作千分位划分，在该位置后面需要有三个数字方能匹配。// 1|2|3|4|5|6|7|8|9 1|2|3|4|5.6|7|8|9 横杠|的位置即是\B匹配的位置]]></content>
  </entry>
  <entry>
    <title><![CDATA[emoji在JS中的使用]]></title>
    <url>%2Fpost-8%2F</url>
    <content type="text"><![CDATA[emoji是什么计算机中的字符都是借助二进制编码来表示，有ASCII，unicode等，ASCII码主要用于显示现代英语和其他西欧语言，其规则是由8个bit组成，第一个bit为0，利用剩余的7个bit组合出128种不同的字符，随着计算机的不断推广，利用单字节编码系统显得力不从心，无法表示出更多的字符，因此需要一个统一的标准，而这就是unicode诞生的原因。 unicode为世界上的所有字符进行了编号，范围从 0x000000 到 0x10FFFF，大多数字符在范围0x0000 到 0xFFFF 之间（即小于 65536），每个字符都有一个 Unicode 编号并且一般用十六进制表示，前置 U+。 emoji也是一个unicode字符，每一个emoji都分配了一个对应的码点（code point），不同的系统对同一个emoji的展示形式也是不同的，如果系统没有实现当前的emoji，那么渲染出来的就是一个系统默认设置的内容 emoji怎么用在js中我们可以使用\uXXXX表示一个unicode字符，其中XXXX表示的是Unicode码点，只能表示常见的字符(即位于0x0000到0xFFFF范围内的字符)，超出范围的需要用两个双字节表示。 12345678//在html中的展示则为 &amp;#x1f61c;//在es6中支持了以下用法输出emoji和对emoji进行解码"\u&#123;1f61b&#125;" //😛String.fromCodePoint("0x1f601") //😛'😛'.codePointAt(0).toString(16) // 1f61b utf8是mysql中的一种字符集，只支持最长三个字节的 UTF-8字符；utf8mb4可以支持四个字节UTF-8编码 ，但是要使用 MySQL 的这个特性，首先需要把 MySQL 升级到 5.5.3 以上的版本。 emoji一般占四个字节，如果使用MySQL存储Emoji, 需要将数据表的字符集设置为utf8mb4, 即CHARSET=utf8mb4，这样就能直接将用户输入的emoji信息完整保存在数据库中。 那么，可以根据一个emojiMapping表，然后利用String.fromCodePoint进行转换然后渲染到视图上，再根据用户的选择再输入框进行拼接，即可实现emoji表情的需求 开发踩坑记录 在小程序中，input输入框如果贴底，会出现软键盘直接无视input框的父元素直接贴住input框，需要给input框加一个margin-bottom 在h5中需要用到长按事件去进行评论的删除，这里用到了touchstart，touchmove，touchend进行模拟，首先在touchstart中设置一个定时器，在定时器中触发注册的回调函数，然后在touchend中将这个定时器清除，如果用户是长按，那么就会触发定时器，如果是点击一下，那么就会在手指离开屏幕的时候触发touchend将定时器清除而不会被触发。在屏幕滚动的过程中由于也会长按屏幕，因此需要做一个区分，滚动过程会触发touchmove事件，因此需要在touchmove中清除定时器。除此之外，长按事件还会触发点击事件，那么需要设置一个计时器，记录touchstart和touchend的间隔时间，如果间隔时间长说明用户希望触发长按事件，那么这里就可以通过preventDefault将点击事件阻止掉 1234567891011121314151617181920212223242526272829303132333435363738// 移动端长按指令Vue.directive("longpress", &#123; inserted: function (el) &#123;&#125;, bind(el, binding) &#123; let timeout = undefined; const INTERVAL = 200 let start = 0; binding.$$startEvent = function (event) &#123; //模拟长按 timeout = setTimeout(binding.value.bind(null, el, event), INTERVAL); start = Date.now()//计时器 event.stopPropagation(); &#125;; binding.$$moveEvent = function (event) &#123; clearTimeout(timeout);//避免和滚动事件冲突 event.stopPropagation(); &#125;; binding.$$endEvent = function (event) &#123; clearTimeout(timeout);//避免和点击事件冲突 event.stopPropagation(); if (Date.now() - start &gt; INTERVAL) &#123;//避免触发祖先元素的点击事件 event.preventDefault(); &#125; &#125;; el.addEventListener("touchstart", binding.$$startEvent, false); el.addEventListener("touchmove", binding.$$moveEvent, false); el.addEventListener("touchend", binding.$$endEvent, false); &#125;, unbind(el, binding) &#123; el.removeEventListener("touchstart", binding.$$startEvent); binding.$$startEvent = null; el.removeEventListener("touchmove", binding.$$moveEvent); binding.$$moveEvent = null; el.removeEventListener("touchstart", binding.$$endEvent); binding.$$endEvent = null; &#125;, update() &#123;&#125;&#125;); 在获取滚动高度的时候，用document.documentElement.scrollTop无效，可以通过document.scrollingElement.scrollTop或者window.scrollY获取 input输入框贴底，会出现软键盘覆盖input框的情况，需要在input框的focus事件中调用scrollIntoView(false)才能正常贴底 input输入框在ios中调起软键盘的时候页面会被上推，但是blur的时候不会回到原本位置，所以需要判断user-agent是否iphone，在输入框的blur事件中将document.scrollingElement.scrollTop减去对应的高度，否则当用户在页面底部调起输入框时，输入框会因位于页面的区域而出现异常]]></content>
  </entry>
  <entry>
    <title><![CDATA[lodash源码学习（一）]]></title>
    <url>%2Fpost-7%2F</url>
    <content type="text"><![CDATA[趁着有时间研究了一下lodash库的一些函数的实现，发现里面对于一些传入参数的判定比较完备，而且也对一些原有的js函数进行了一些扩展。after 1234567891011121314151617181920212223242526/** * * @param &#123;number&#125; * @param &#123;Function&#125; * @returns &#123;Function&#125; * * * const saves = ['profile', 'settings'] * const done = after(saves.length, () =&gt; console.log('done saving!')) * * forEach(saves, type =&gt; asyncSave(&#123; 'type': type, 'complete': done &#125;)) * // =&gt; Logs 'done saving!' after the two async saves have completed. */function after(n, func) &#123; if (typeof func != 'function') &#123; throw new TypeError('Expected a function') &#125; return function(...args) &#123; //n小于1的时候都会马上执行 if (--n &lt; 1) &#123; return func.apply(this, args) &#125; &#125;&#125;export default after after的功能是待函数的触发了n次后才真正执行。after接受两个参数，一个是执行次数n，还有一个是待执行的函数，如果需要传入参数可以使用bind。 before 12 before的功能是限制函数的执行次数为n-1，如果n小于0则不执行。before接受两个参数，一个是执行次数n，还有一个是待执行的函数，如果需要传入参数可以使用bind。 chunk 12 首先引入了slice，其目的是利用扩展了的slice实现深复制，chunk接受两个参数，分别是待分组的数组array，以及每一分组的元素数目size，如果不够分则剩下的归为一组。 defer 123456789101112131415161718/** * * @param &#123;Function&#125; * @param &#123;...*&#125; [args] * @returns &#123;number&#125; * * defer(text =&gt; console.log(text), 'deferred') * // =&gt; Logs 'deferred' after one millisecond. */function defer(func, ...args) &#123; if (typeof func != 'function') &#123; throw new TypeError('Expected a function') &#125; //延迟1ms执行 return setTimeout(func, 1, ...args)&#125;export default defer defer函数的功能是延迟执行，接受两个参数，分别是需要延迟执行的函数func，还有需要传给func的参数。 这里利用了settimeout将函数放入宏任务队列中实现了延迟，会在js主线程和微任务队列执行结束后执行。 delay 1234567891011121314151617181920/** * @param &#123;Function&#125; * @param &#123;number&#125; * @param &#123;...*&#125; * @returns &#123;number&#125; * * delay(text =&gt; console.log(text), 1000, 'later') * // =&gt; Logs 'later' after one second. * */function delay(func, wait, ...args) &#123; //类型判断，必须是函数 if (typeof func != 'function') &#123; throw new TypeError('Expected a function') &#125; //返回一个定时器,保证wait为Number类型 return setTimeout(func, +wait || 0, ...args)&#125;export default delay delay接受至少三个参数，分别是需要延迟执行的函数func，延迟执行的时间wait，以及需要向func传入的参数，返回的是定时器的id，可以根据该id对定时器进行清除，delay实现了延迟执行的功能。 像这里这种在settimeout给func传参写法在IE9以下是不兼容的，需要polyfill 1234567891011121314(function()&#123; setTimeout(function(arg)&#123; if(arg==='test')&#123; return; &#125; const __nativeST__ = window.setTimeout; window.setTimeout = function(callback,delay)&#123; const args = Array.prototype.slice.call(arguments, 2); return __nativeST__(function(callback instanceof Function?function()&#123; callback.apply(null, args); &#125;):callback,delay) &#125; &#125;,0,'test')&#125;()) forEach &amp;&amp; each 12345678910111213141516171819202122import arrayEach from './.internal/arrayEach.js' //处理数组的遍历import baseEach from './.internal/baseEach.js' //处理类数组的遍历/** * * @param &#123;Array|Object&#125; * @param &#123;Function&#125; * @returns &#123;Array|Object&#125; * * forEach([1, 2], value =&gt; console.log(value)) * // =&gt; Logs `1` then `2`. * * forEach(&#123; 'a': 1, 'b': 2 &#125;, (value, key) =&gt; console.log(key)) * // =&gt; Logs 'a' then 'b' (iteration order is not guaranteed). */function forEach(collection, iteratee) &#123; //判断是数组还是类数组，分别进行不同的处理 const func = Array.isArray(collection) ? arrayEach : baseEach return func(collection, iteratee)&#125;export default forEach forEach的功能是遍历数组和类数组，扩展了原生forEach的功能，主要是通过循环遍历之后将新变量注入到遍历器触发的函数中，实现了该功能，forEach还有一个alias为each isArrayLike 12345678910111213141516171819202122232425import isLength from './isLength.js'/** * * @param &#123;*&#125; * @returns &#123;boolean&#125; * * * isArrayLike([1, 2, 3]) * // =&gt; true * * isArrayLike(document.body.children) * // =&gt; true * * isArrayLike('abc') * // =&gt; true * * isArrayLike(Function) * // =&gt; false */function isArrayLike(value) &#123; return value != null &amp;&amp; typeof value != 'function' &amp;&amp; isLength(value.length)&#125;export default isArrayLike isArrayLike功能是判断是否是类数组对象，即value是否是有效的length，isLength函数实现了该功能，isArrayLike接受一个参数value，由于历史遗留问题，null也被视为一个对象，因此需要排除，同时Function类型也有length属性，但是代表的是参数的个数，不是类数组，因此也需要排除。 isLength 123456789101112131415161718192021222324252627//最大安全整数const MAX_SAFE_INTEGER = 9007199254740991/** * * @param &#123;*&#125; * @returns &#123;boolean&#125; * * * isLength(3) * // =&gt; true * * isLength(Number.MIN_VALUE) * // =&gt; false * * isLength(Infinity) * // =&gt; false * * isLength('3') * // =&gt; false */function isLength(value) &#123; return typeof value == 'number' &amp;&amp; value &gt; -1 &amp;&amp; value % 1 == 0 &amp;&amp; value &lt;= MAX_SAFE_INTEGER&#125;export default isLength isLenth的功能是判断该对象是否有一个有效的length属性，其接受一个参数value，value必须是Number类型且必须为非负整数，同时不能超过最大整数 last 12345678910111213141516/** * * @param &#123;Array&#125; * @returns &#123;*&#125; * * last([1, 2, 3]) * // =&gt; 3 */function last(array) &#123; //判断是否数组，如果是则获取数组长度，否则设置为0 const length = array == null ? 0 : array.length //如果length大于1，则返回数组最后一个元素，否则返回undefined return length ? array[length - 1] : undefined&#125;export default last last函数的功能是获取数组最后一个元素，last接受一个参数，期望该参数是数组，并对其不是数组时进行了异常处理 slice 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * @param &#123;Array&#125; * @param &#123;number&#125; * @param &#123;number&#125; * @returns &#123;Array&#125; * * const array = [1, 2, 3, 4] * _.slice(array, 2) //[3, 4] */function slice(array, start, end) &#123; //数组长度，如果是空数组,则为0 let length = array == null ? 0 : array.length //如果是空数组，则返回新数组 if (!length) &#123; return [] &#125; //处理start，默认为0 //由于undefined==null为true，因此缺省时默认深复制整个数组 start = start == null ? 0 : start //处理end，缺省时默认为length end = end === undefined ? length : end if (start &lt; 0) &#123; //当start小于0时，判断边界，如果超出数组长度则置0 //否则就是length减去start的绝对值 start = -start &gt; length ? 0 : (length + start) &#125; //同理，当end大于数组长度时，则设置为数组长度 end = end &gt; length ? length : end if (end &lt; 0) &#123; //end小于0则length减去end的绝对值 end += length &#125; //当start大于end的时候，则返回空数组 //否则算出复制的范围，不包括end //&gt;&gt;&gt;是无符号右移，目的是取整 //这里的判断包含了start超过length的情况 length = start &gt; end ? 0 : ((end - start) &gt;&gt;&gt; 0) start &gt;&gt;&gt;= 0 //这个是flag值 let index = -1 //创建一个新数组 const result = new Array(length) //进行复制 while (++index &lt; length) &#123; result[index] = array[index + start] &#125; //返回新的数组 return result&#125;export default slice 根据提供的start、end参数，深复制一个数组的一部分。扩展了原生数组的slice的功能，start和end可以接受负数，表示到end的距离，start默认为0，end默认为传入数组的长度。利用&gt;&gt;&gt;0右移实现取整，对start和end的可能情况进行处理，分别是start和end缺省时，start和end超出边界值时，start大于end时，start和end为非整数时 once 1234567891011121314151617import before from './before.js'/** * * @param &#123;Function&#125; * @returns &#123;Function&#125; * * const initialize = once(createApplication) * initialize() * initialize() * // =&gt; `createApplication` is invoked once */function once(func) &#123; return before(2, func)&#125;export default once once函数的功能是只会执行一次函数，通过before函数控制，once接受一个参数func]]></content>
  </entry>
  <entry>
    <title><![CDATA[聊聊Webpack]]></title>
    <url>%2Fpost-6%2F</url>
    <content type="text"><![CDATA[webpack是什么webpack是目前常用的前端打包构建工具，提高前端工程化水平，将一些重复性的工作交由工具完成，在开发阶段只需要专注于业务的实现即可，webpack也提供了一些优化构建的方法。 webpack在生产发布中主要用到的属性是entry，output，resolve，module，plugins，开发阶段还用到devServer等，在webpack4中提供了dev和prod环境的一些默认配置，通过mode属性去控制。 entry 1234567//entry是一个入口，webpack的依赖解析就是从这个入口开始，接收的参数为字符串或者数组或者object//如果是object，则它的key会被保存在[name]中，可以在output中使用&#123; entry:&#123; a:'./src/aaa.js' &#125;&#125; output 1234567891011//output是输出的路径,将entry中的文件输出到指定路径path中，其中__dirname是当前的配置文件对应的路径//publicPath在开发环境一般用的比较少，用在生产环境较多，可以自动替换静态资源的路径//例如我们引入静态资源可能是'./xxx.png',生产环境中有可能需要会放在其他地方，例如放到CDN上，候就可以通过配置这个自动替换，将./替换成CDN的路径//filename则是输出的文件的名字，[name]则是对应entry中的key，而[hash]则是根据每次打包生成的一个hash值，还有[chunkhash]，这是根据内容生成的hash值，可用于长时间缓存，不过还需要搭配namedchunkplugin和namedmoduleplugin等使用&#123; ouput:&#123; filename:'[name].[hash].js', path: path.resolve(__dirname,'dist'), publicPath: './ZZZ' &#125;&#125; resolve 1234567891011//resolve是解析方法，webpack为我们提供了一套enhance-resolve//extensions可以设置后缀，例如对于import aaa from 'XXX';webpack会根据extensions的配置的扩展名进行匹配，而modules则是可以为webpack指定搜索范围，减少不必要的检索，提高效率//alias则是可以用来配置别名，例如import aaa from '@/XXX'；那么webpack就会根据别名去src/components/XXX.js中加载//设置别名的好处就是使用了绝对路径，当以后文件结构发生变动的时候，只需要在webpack的配置中更改一次就可以了，不需要每一个文件都更改一次，提高了效率&#123; extensions:['.js','.less'], alias:&#123; ‘@’：path.resolve(__dirname,'src/components') &#125;, modules:[path.resolve(__dirname,'node_modules')]&#125; module 123456789101112131415161718192021//rules一般是用来设置loader，因为webpack会通过loader将其他文件转换为它能处理的js文件//rules是一个数组，数组的元素是对象，对象中的test是用正则表达式来筛选处理的文件，include或者exclude可以是字符串或者数组或者函数，表示搜索或者排除其中设置的路径//use也是一个数组，其中的元素的是对象，loader指定处理的加载器，options是为加载器提供参数，如果传入多个loader，则处理顺序是从数组尾部到头部&#123; rules:[ &#123; test: /\.js$/, include:[path.resolve(__dirname, 'src')], exclude:[path.resolve(__dirname, 'node_modules')], use:[ &#123; loader: 'babel-loader', options:&#123; presets:[], plugins:[] &#125; &#125; ] &#125; ]&#125; plugins 123456789//lugins中则是配置一系列plugin的实例，处理经过加载器处理过的chunk[ new CleanWebpackPlugin(['dist']), new HtmlWebpackPlugin(&#123; template: './src/index.ejs', filename: 'index.html', inject: true, &#125;),] devServer 12345678//devServer则是开发环境常用的一个服务器，提供热更新和替换的功能，在文件变动的时候可以自动刷新，需要配合new webpack.HotModuleReplacementPlugin()这个plugin使用//devServer并不会在磁盘上生成文件，而是把文件储存在内存中，所以我们通过fs模块没办法操作，可以通过memory-fs模块操作，contentBase则是类似于output中的path//在开发环境可以利用proxy将一些请求代理到我们的服务器中进行测试&#123; contentBase: './dist', hot: 'true', proxy:&#123;&#125;&#125; webpack原理及使用 打包流程 webpack的理念是一切皆模块，首先从entry出发，构建出依赖图，然后根据依赖图加载文件，通过loader把各种文件转换成它能处理的js模块，在loader中的处理就像是水流从水管中流过，buffer数据流就像水流，流经每个loader，经过处理后流出到下一个loader中，然后用plugin进行处理。webpack中有两个关于模块的概念，分别是module和chunk，我们打包出来的都是chunk，而chunk由很多module构成，每个文件中引入的外部文件就是module。 加载的实现 对module的加载，webpack的处理和node的require模块差不多，也是加载文件，缓存加载过的文件，避免循环引用，然后在外层套一层函数定义把参数传入，隔离出作用域。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152(function(modules) &#123; //将module缓存 var installedModules = &#123;&#125;; //这里是形成闭包返回，这里的实现和node的require模块的实现一样 function __webpack_require__(moduleId) &#123; //如果module已经被加载过，直接返回出去 if(installedModules[moduleId]) &#123; return installedModules[moduleId].exports; &#125; //未被加载过则进行加载并记录 var module = installedModules[moduleId] = &#123; i: moduleId,//唯一的moduleid l: false,//是否加载过的标志 exports: &#123;&#125;//要暴露的方法 &#125;; //将context绑定到module.exports中，将module，module.exports,__webpack_require__作为参数传入 modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); //标志加载完成 module.l = true; //将module.exports返回 return module.exports; &#125; //静态方法，将modules绑定，此处的modules是一个对象，对象里面是一个函数 __webpack_require__.m = modules; //静态方法，将缓存的module信息返回出去 __webpack_require__.c = installedModules; // 静态方法，这里可以处理es6的ESM，ESM引入的时候_esModele的值为true，exports default将变为commonJS的exports.default __webpack_require__.r = function(exports) &#123; if(typeof Symbol !== 'undefined' &amp;&amp; Symbol.toStringTag) &#123; Object.defineProperty(exports, Symbol.toStringTag, &#123; value: 'Module' &#125;); &#125; Object.defineProperty(exports, '__esModule', &#123; value: true &#125;); &#125;; //...... //moduleid以路径为映射，输出的是module.exports的内容 return __webpack_require__(__webpack_require__.s = "./b.js"); &#125;) (&#123;//这里是将字符串通过eval()函数激活 (function(module, exports) &#123; eval("\n\n\nmodule.exports = &#123;\n test: function()&#123;\n console.log('bbbbb')\n &#125;\n&#125;\n\n//# sourceURL=webpack:///./b.js?"); &#125;)&#125;); 我们需要注意的是，webpack对module和chunk的命名处理是在内部维护了一个id的映射，并且id是自增的，也就是说，文件的增加减少也会导致命名的变化，即使内容并没有改变，因此当我们需要对一些第三方库和框架进行缓存的时候，需要用到namedmoduleplugin和namedchunkplugin进行处理，使得命名不会因为文件的变动而在打包构建的时候发生变化，破坏了浏览器的缓存效果。 分包优化机制 针对打包构建，webpack3用的是commonschunkplugin，基于父子关系依赖图进行的公用包分割模式，主要是根据minchunk，也就是引用的次数进行划分。而在webpack4中，舍弃了commonschunkplugin而起用了spiltchunkplugin，这是基于graghGroup进行的分割，其中有一个chunks属性，提供了三种模式，默认是”async”，还有的是”initial”，”all”，为了弄清这三种模式的区别，利用了可视化工具尝试进行了打包，其中在a，b文件中，lodash都是动态引入的，而jquery都是静态引入的，moment则是一个动态一个静态的 这是initial模式的打包结果，这里a，b中的所有模块都被提取了出来，而且jquery被合并了 ，但是moment和lodash却没有被合并 这是async模式的打包结果，这里a，b中的jquery没有被提取出来 ，而lodash则被提取了出来，a中的moment被提取了，而b中的却没有 这是all模式的打包结果，a，b中的模块都被提取了，而且相同的模块都合并了 从以上三张图可以看出，三种模式的区别，在async模式下，只有动态加载的公共包才会被提取出来，在initial模式下，其涵盖了async的功能，所有包都被提取了出来，但是只有静态引入的包才会被合并，而在all模式中，所有的包都被提取出来并且合并了。 由此可见，splitchunk的功能还是很强大的，我们可以根据不同的需求使用不同的模式进行分包，例如框架这些是很少会变动的，而且体积也比较大，这些可以利用all模式打包到一起进行缓存，然后是第三方库这些变动的可能行也是比较小的，这些可以打包到一起进行缓存，剩下的公共包根据实际情况打包，在第一次进入页面的时候进行加载，减少重复的代码。 静态引入和动态 通过动态引入可以实现按需加载的功能，webpack中支持es6的import()语法，对于文件的引入大致有三种方案。 CMD，这是同步的实现方案，因为这个是同步的加载，而且是运行时操作，加载后的文件变转换成一个exports对象，其中this会指向他，由于是在服务器中，直接从硬盘中读取文件，阻塞线程也不怕，所以同步加载也可以。 AMD，这是在异步的实现方案，这个一般运行在浏览器端，也是运行时操作，因为浏览器需要从服务器请求数据，所以使用异步的方案比较好，不然会阻塞当前线程，无法处理用户的交互信息。 ESM，这是ES6提出来的方案，利用import引入，也可以根据需要只引入部分代码，利用export将代码分割，相当于一个文件中每一个export都是一个小文件。这并不是在运行时进行加载，而是在编译的时候就确定了加载的文件，因此import中的文件路径不支持变量，只能写常量，能够export的只是有确定值的变量或者函数，对象等，否则会报错 。 可以利用import()进行动态加载，webpack会将这些文件进行codesplit自动分割成不同的chunk，而且在webpack中可以以变量加字符串的形式引入，例如import(../models/${component})，这是因为webpack有一个context，这种写法webpack会将../models中的文件全都加载到chunk中，或者可以使用require.context方法实现动态引入，这样也可以实现路由的去中心处理，也可以实现对一些使用频次较高的库或者插件的自动引入而不需要每个页面都手写一次 API钩子 webpack也提供了很多钩子，例如module.hot的热更新钩子，还有loader处理相关的钩子，plugin相关的钩子可以控制plugin运行的位置 webpack的配置文件是一个对象，我们可以将这个对象config作为参数传入webpack(config)，这会产生一个compiler实例，通过compiler.run可以启动webpack等等 最后由于框架提供的脚手架用起来不方便，也不能随便跟着脚手架和框架的更新而更新，于是尝试着用webpack去打包，并且在团队中用起来，现在搭好了开发和生产环境，在过程中也研究了一下webpack的相关内容，准备进行一些优化。 由于antd中的less文件的样式如果使用了cssmodules，那么会在每个命名后面加上hash，样式无法正常显示，因此在使用loader的时候需要分开处理，对node_modules中的less不进行cssmodules处理。 由于antd的默认icon无法满足实际需要，因此需要对其进行扩展，但是在引入静态资源的时候需要对路径进行映射，因此需要设置less-loader中options的path，改变context，将根路径/映射到/public中，而且在引入自己的iconfont的时候通过增加选择器权重，兼容性的扩充原有的anticon。]]></content>
  </entry>
  <entry>
    <title><![CDATA[React用法解析]]></title>
    <url>%2Fpost-5%2F</url>
    <content type="text"><![CDATA[dva是什么dva是对 redux + react-router + redux-saga 等的一层封装，提供了一个models，常用的属性如下：namespace，state，effects，reducers，subscriptions。 models维护了一个全局的状态，models中可以通过namespace的属性对各个状态进行隔离，相当于划分了一个作用域，然后通过@connect可以将state注入到需要用到的组件中，组件可以通过自身的props访问到这个state， 如果需要改变state，就可以通过effects和reducers，前者是一个generator，用来处理异步逻辑，后者则是处理同步逻辑，在组件中可以通过使用dispatch函数去触发effects或reducers，dispatch函数会返回一个promise，因此我们可以在reducers或者effects中通过return将数据直接返回给dispatch，而subscriptions则是可以订阅路由的变化。123456789101112131415161718192021222324252627282930313233343536namespace:'A',state:&#123; &#125;,effects:&#123; *B(state,&#123;call,put&#125;)&#123; //其中的call则是用来触发services中的函数去请求数据，用法类似于js中的call //const a = yield call(X,参数) //put则是用来触发reducers更改state的状态 //const action = &#123;type:'B/XX',payload&#125; //yield put(action) &#125;&#125;,reducers:&#123; c(state,action)&#123; //处理逻辑 return&#123; ...state, XXX:action.payload,//XXX是需要改变的state，习惯上payload是action中的传过来的新state，可以自定义 &#125; &#125; &#125;,subscriptions: &#123; //这里可以传入dispatch或者history等 setup(&#123; dispatch,history &#125;) &#123;\ //可以进行history的监听，当路由变动时可以执行回调 return history.listen(location) =&gt; &#123; //回调的代码 //也可以用dispatch触发reducers更改state状态 //如果reducers是相同namespace下的则不需要添加前缀，如果不同则需要添加 //const action = &#123;type:'B/XX',payload&#125; //例如有一个namespace是B的，则需要dispatch(action) //其中payload是需要最新的state &#125;); &#125;, &#125;, 由此我们可以实现一个MVC的结构，services文件负责管理向后端的接口请求，每个请求都需要用到fetch，那么对request可以进行简单的封装，models文件负责数据的储存和管理，然后components和routes文件则是用于渲染的组件， 12345|--src |--routes //页面路由渲染组件 |--components//公用组件 |--services//请求接口 |--models//状态管理和数据储存 redux-sagaredux是react的全局状态管理的实现，它接收组件dispatch传来的type和payload，然后对type命中之后，用payload中的值更新redux中的state，这解决了react自身的跨层级和兄弟组件之间通信不方便的问题，也降低了组件之间的耦合度，在未使用redux的时候，react兄弟组件A，B间的通信需要借助父组件作为媒介，A将需要传递的信息通过props中的回调函数传递到父组件，父组件再通过props传递给B组件，而跨层级的通信则是需要通过层层props传递，或者使用contextAPI传递，这些都增加了组件之间的耦合度。 roadhogroadhog是一个react的脚手架，它定制了一套配置，提供了一些字段，方便给开发者使用。使用的时候只需在.hoadloadrc文件中设置即可，在源码中还有如下逻辑，如果设置了roadhog.conifg.js，那么它将会以roadhog.conifg.js中的配置为准，在读取了配置之后，它会去调用config文件夹下的webpack.config.js中的逻辑。 虽然roadhog高度定制了一套配置，减少了开发者的配置时间，但是也是由此，而不方便针对项目进行调整。在roadhog1.X中，没有提供别名alias和公共包分离的功能，如果支持别名，则可以对公共组件的引用使用绝对地址，方便应对将来文件结构的变动的影响，公共包分离的功能虽然提供mulitpage字段，但是从源码中看到这个是默认去调用commonchulksplugin并输出到common文件中，但是得手动设置entry和将需要的插件分离，而且不便于将webpack打包的运行时分离，会导致每次打包的hash值都会改变，无法起到缓存作用。 这两个功能在2.X版本中进行了支持，分别提供了alias和common字段，在1.X版本的话就需要用到babel-transform-resolver提供别名，分包的话在github上作者提供了一个enhancement，在打包的时候加上–config参数，值是自己的webpack配置文件。 123456789&#123; "entry":""//入口文件 "output":""//打包输出路径，默认为./dist "env":&#123;&#125;//设置开发环境和线上环境的配置 "hash":false,//是否对打包出来的文件添加hash内容，默认false "proxy":&#123;&#125;,//设置请求代理 "muiltpage":false，//多页面，开启可以进行分离公共包，默认false "extraBabelPlugins":[]//引入babel&#125; react-router单页面应用都需要借助路由实现进行页面内的无刷新跳转，路由主要是依靠在route组件中传入path属性，path属性是一个路径，如果浏览器的url中path命中，那么就会将该route的组件进行渲染，因此还可以传入component属性，值为需要渲染的组件，使用getComponent函数则可以实现路由的按需加载，dva提供了dynamic函数进行按需加载，使用的route组件需要包裹在router组件中 1234&lt;Router&gt; &lt;Route path="/a" component=&#123;&#125;&gt;&lt;/Route&gt; &lt;Route path="/a" getComponent=&#123;fn(component,callback)&#125;&gt;&lt;/Route&gt; //按需加载&lt;/Router&gt; 路由跳转则依靠Link组件，可以传入to或replace属性，route组件会被渲染成a标签，to和replace属性都可以传入一个location对象，其属性是pathname，state，search，hash，区别是to相当于pushState，往浏览器的路由栈中压入路径，replace相当于替换当前页面的路径。 1&lt;Link to=&#123;location&#125;&gt;&lt;/Link&gt; redirect组件则是当path命中时，to到指定路径，也即是实现了重定向的功能。 1&lt;Redirect path="/a" to="/abc"&gt;&lt;/Redirect&gt; // 路径/a会跳转到/abc 在被渲染的组件中，我们可以通过props访问到location属性和match对象属性，match对象中用的比较多的是params，它是一个对象，存放着pathname中的变量，例如12345678910111213```javascriptlocation = &#123; pathname,//这个的值是不包括域名的路径 state,//如果页面刷新，state的数据会丢失，正常情况state会随着路由跳转可以在下一个页面的location中取到，类似post的body数据，不会出现在浏览器url中 hash, search, //search的值&apos;?XXX=aaa&amp;XX=bbb&apos;，需要自己进行解析&#125;match:&#123; params:&#123;&#125; // 假设/a/b/c/:d/e/:f,那么params中的值则为d，f的键值对 url, //和浏览器中的url一致 path,//和route中写的path一致&#125; react传统的JS框架都是以操作dom为主，由于dom十分臃肿，创建开销大，频繁操作更是会引起重回和回流，这些都会对性能造成影响。 react则提出了虚拟dom，解决了这个问题，虚拟dom是一个JS对象，它包含了tagName，props，children 12345const virtualDom = &#123; tagName: 'div', //组件命名 props:&#123;&#125;, //组件的属性 children:[],//组件中的子元素&#125; 虚拟dom保留了主要的信息，利用这些信息我们可以构建出一个虚拟dom树结构，这个虚拟dom树相当于是真实dom的一个映射，消耗的资源也是极少的。有了这个映射，那么我们的所有逻辑都无需直接去操作真实dom了，直接操作虚拟dom然后再一次性的映射到真实dom上改变真实dom。 这里我们就需要一个diff算法去对比虚拟dom和真实dom，找出被更改的元素，状态，属性等，原本对比两棵树的时间复杂度是O(n3)，这在实际操作中是不能接受的，而react就对diff算法进行了改进，把diff算法的复杂度降到了O(n)。 diff策略这是建立在三个基本假定之上的diff策略： dom节点跨层级的移动操作特别少，可以忽略不计 拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构 对于同一层级的一组子节点，它们可以通过唯一 key 进行区分 在进行diff算法的时候，如果两个组件不同，那么就不会继续往下比对而是直接将其销毁，并生成新的component，如果组件相同就会对state和props进行比对，state和props不同则直接更新组件的state和props，这里需要注意一点，子组件是无法变更props的，除非是通过子向父传递信息的方式调用父组件的setState方法，去改变父组件的state进而造成子组件的props发生变化，除此之外，react还会通过唯一的key对组件进行区分 对于这种情况，react只会移动组件，而不是销毁重新创建新组件，这往往对列表的渲染影响比较大，如果列表渲染时不带key，那么如果对列表按某一列进行排序，那么react会对这些数据重新销毁重建，而实际情况是这些组件只是改变了位置。 12345//还有一种情况如下，在渲染列表的时候，从头部插入数据和从尾部插入数据也会有不同的结果，//react会对每一项进行比对，从头部插入，那么每一项的对比都会认为是不同的数据，从尾部插入，那么前三项则是相同的，只是最后一项是不同的数据[1,2,3] [4,1,2,3][1,2,3,4] react的生命周期ES5： 12345678910111213getDefaultProps()&#123;&#125; //获得propsgetInitialState()&#123;&#125; //初始化statecomponentWillMount()&#123;&#125; //虚拟dom即将挂载，在这里调用setState不会触发重新渲染，还有一点需要注意的是未成功挂载之前，是无法获得component的ref的render()&#123;&#125;//视图渲染componentDidMount()&#123;&#125;//挂载完成，这个阶段只会执行一次，重渲染时不会执行，一般会在这个阶段请求数据，在这里需要注意的是，如果利用props的值时有可能props还未返回，所以需要进行容错性处理componentWillRecieveProps(nextProps)&#123;&#125;//props值变化时会触发重新渲染，这里使用setState不会触发重新渲染shouldComponentUpdate(nextProps,nextState)()&#123;&#125;//如果return false则不会进行重新渲染，否则会重新渲染，因此我们可以在这里进行一些逻辑判断避免多余的重新渲染componentWillUpdate()&#123;&#125;render()&#123;&#125;//视图渲染，不要在这里setState，会导致死循环componentDidUpdate()&#123;&#125;//不要在这里setState，会导致死循环componentWillUnmount()&#123;&#125; //组件销毁前的事件钩子，一般用来销毁定时器和移除自己用addEventListener的事件监听，避免组件销毁后造成内存泄漏 ES6： 123456789Class Acomponent extends Component&#123; //getDefaultProps和getInitialState放在这里进行 constructor(props)&#123; super(props); this.state = &#123;&#125;; //在ES6中我们可以用箭头函数代替ES5中的Afun.bind(this)转换this的指向，因为在react的合成事件中的this会指向触发该事件的元素 //或者我们也可以在这里调用bind，因为可以使bind只是调用一次，如果在合成事件例如onClink=&#123;Afun.bind(this)&#125;会导致每次点击的时候都会触发bind事件 &#125;&#125; 对于react的合成事件，react已经将所有的事件都自动挂载在了document上，因此所有的事件都会冒泡到document上进行触发，使用合成事件我们就不需要在组件销毁时对移除事件监听，react自动帮我们进行管理。 setState在react中我们如果希望更新视图，那么通常是会通过setState触发状态改变，然后触发react的重新渲染的过程，如果只是对state赋值进行的变更，是不会触发重新渲染的。 123456789101112131415161718//setState接受两个参数，setState（fn|Object,callback）//第一个参数如果是Object，那么setState的处理就是把Object合并，如果是函数，那么就会被放入一个队列中，一次执行。而第二个参数则是状态变更完成后的回调，即能再回调中获取到最新的state//针对setState，react也进行了一些优化//setState的执行是"异步"的，加引号是因为这里并不是真正意义上的异步，只是react为了避免频繁的对state进行改动，它的处理方式是将setState的执行内容放到js主线程执行完之后再一次性执行，然后进行一次性进行diff算法//以下执行了三个setState，由于传入的是对象，那么react的处理是，将这三个对象和state进行合并，类似Object.assign(),然后setState的执行是"异步”的，那么在回调中能获取到a的值为1，可是同步的获取a的值为0state = &#123;a:0&#125;this.setState(&#123;a:this.state.a+1&#125;)this.setState(&#123;a:this.state.a+1&#125;)this.setState(&#123;a:this.state.a+1&#125;,()=&gt;&#123;console.log(this.state.a) //1&#125;)console.log(this.state.a) //0//以下执行了三个setState，由于传入的是函数，那么react的处理是，将这三个函数放到一个队列中，依此执行，每个函数中都有一个state参数，这里能拿到最新的state，在回调中能获取到a的值为3state = &#123;a:0&#125;this.setState(state=&gt;&#123;state.a++;console.log(state.a))//1this.setState(state=&gt;&#123;state.a++;console.log(state.a))//2this.setState(state=&gt;&#123;state.a++;console.log(state.a),//3 ()=&gt;&#123;console.log(this.state.a)&#125;)//3 父子之间的传值父-&gt;子：父组件通过props即可向子组件传值 子-&gt;父：通过props中传递函数的形式传值 12345678910111213141516171819202122232425class Parent extends Component &#123; constructor(props)&#123; super(props) this.state=&#123; parentval:0 &#125; &#125; parentfn(childval)&#123; console.log(childval)//555 &#125; render()&#123; return &lt;Child parentfn=&#123;this.parentfn&#125; &gt;&lt;/Child&gt; &#125;&#125;class Child extends Component &#123; constructor(props)&#123; super(props) this.state=&#123; childval:555 &#125; &#125; render()&#123; return &lt;div onClick=&#123;this.props.parentfn(this.state.childval)&#125;&gt;&lt;/div&gt; &#125;&#125; React v16react v16提供了一些新的特性，例如： 利用React.Fragment作为render中return的标签或者组件的根元素，而这个Fragment在渲染的时候不会被渲染出来，而在v16之前我们一般用div作为根元素进行包裹 render中return可以返回一个标签数组[‘‘,’‘,’‘] 提供了createRef去获取组件的ref 123456789101112131415161718192021//v16class A extends Component &#123; constructor(props)&#123; super(props) this.state=&#123;&#125; this.input = React.createRef(); &#125; render()&#123; return &lt;input ref=&#123;this.input&#125;/&gt; &#125;&#125;//V16之前class A extends Component &#123; constructor(props)&#123; super(props) this.state=&#123;&#125; &#125; render()&#123; return &lt;input ref=&#123;(input)=&gt;&#123;this.input=input&#125;&#125;/&gt; &#125;&#125; 虚拟dom的结构不是树而是变成了链表，提出了fiber模式，过去如果我们需要渲染大量结点的时候，由于diff算法的比对是不能中断的，占用了js主线程时间，表现出来就是页面假死不能对用户交互做出响应，而如今架构换成了链表之后可以随时暂停，那么diff算法就可以拆分在不同的时间片中，根据不同的优先级进行资源的抢占，例如用户交互的优先级高，在时间片中就可以根据优先级对不同情况进行响应。 总结 React与Angular相比，它在处理数据量不大的情况时，比angular的脏检查机制更有优势，因为angular需要对所有数据进行比对，可是在处理数据量大时由于每次都需要进行依赖收集，就不如angular有效率。 React与Vue相比，没有双向绑定，也没有指令，但是通过虚拟dom建立model层和view层的联系，每个组件维护自身的state，更适合组件化的开发模式。 在React v16的fiber模式，解决了大量结点渲染造成页面假死的情况，拆分成不同时间片中执行diff，体现了化整为零的思想，而这种思想在计算机领域处处可见。 目前用了react和antd做了半个月的业务，总结了部分所得： pagination的current属性的值只接受number，要注意赋值之前对变量的处理 因为用了redux，很多时候请求接口获得的数据是通过props注入的，对props要习惯进行容错性处理，由于props变动会导致组件重新渲染，因此需要在shouldComponentUpdate中进行逻辑判断，避免无意义的重新渲染，也要注意对setState的使用 在TimePicker组件中，onchage回调会返回一个表示TimePicker的开闭情况的参数，根据返回的参数直接setState可以实现点击非TimePicker区域关闭TimePicker，如果自己更改了会导致该功能失效 组件的ref属性会在组件挂载之后才能拿到，未挂载之前获取的值是undefined redux中的state会在浏览器刷新的时候被清掉，Route组件中to属性传的location中的state也会被清掉，因此可以对一些数据利用sessionStroage进行保存，或者将数据存服务器，在刷新的时候从服务器获取，或者记录在浏览器的URL中，在做面包屑功能的时候我就记录在浏览器URL中，因为有一些页面可以从两个不同的页面跳转，只是建立路由和名字的映射表记录跳转无法解决刷新清除state的问题，需要根据URL上记录的from信息，再根据映射表将祖先路由找回来]]></content>
  </entry>
  <entry>
    <title><![CDATA[docker和git的使用]]></title>
    <url>%2Fpost-4%2F</url>
    <content type="text"><![CDATA[docker是什么docker是一种虚拟技术，和虚拟机差不多，但是没有虚拟机这么臃肿，因为虚拟机需要运行一个操作系统，需要宿主机更多的资源，而docker提供一个隔离的环境，它有一个守护进程，根据需要向宿主机申请资源。如果把宿主机比作一片大海，那么docker就是航行在海上的巨轮，而docker容器中的镜像则是巨轮上的货物，而docker则为这些货物提供了一个隔离外部环境的空间 docker优点 便捷docker容器里面可以运行不同的镜像，根据不同需要将不同镜像进行组合，定制一个开发需要的环境，也方便开发完成后一键部署到线上 灵活，镜像在刚拉下来的时候是初始的基础镜像，docker每运行一次RUN命令就会生成一个新的层级去覆盖原有的内容，所以可以根据不同情况进行对基础镜像进行修改，而这个也是docker可以方便组合出不同环境的原因 轻量，docker不像虚拟机需要运行整个操作系统，只要在运行时根据需要向宿主机申请资源即可 使用docker 首先确定系统打开了HypeV虚拟化，如果没打开需要进入bios中将虚拟化打开 对于window系统，首先去官网上将docker for window下载下来，然后安装之后右下角出现一个小鲸鱼就是成功启动了 默认用的是国外的镜像拉取，可以在Daemon面板的Registry mirrors中设置阿里云的镜像 我们可以用pull```命令拉取镜像，```docker rmi```命令删除镜像12- 我们可以把需要的命令和操作提前写在dockerfile中，然后再运行，这样能把需要的镜像和资源一键拉取，定制docker images```dockerfile FROM images:tag #必须以FROM这个作为第一行开头，images表示的是启动的镜像，tag表示的是版本，如果本地没有该镜像那么会从网上拉取，如果未写明tag,则会拉取latest版本 EXPOSE 8888 #EXPOSE关键字暴露Docker服务端容器对外映射的本地端口，容器和宿主机通信的通道 RUN apt-get update &amp;&amp; apt-get install -y vim cron ssh #执行每条RUN指令将在当前镜像基础上执行指定命令，并提交为新的镜像，后续的RUN都在之前RUN提交后的镜像为基础，这个就是docker的镜像分层 RUN mkdir -p /work #这里是在docker中创建一个work路径WORKDIR /work #等同于cd的功能，切换到work路径下 RUN mkdir -p /root/.ssh #在root路径下创建.ssh文件COPY ./conf/.ssh /root/.ssh #复制.ssh文件到docker容器中RUN ssh-keyscan -t rsa XXX &gt;&gt; /root/.ssh/known_hosts #生成用于ssh连接的秘钥 COPY ./server/requirements.txt /work #从宿主机复制文件到docker容器的work路径中RUN pip install -r requirements.txt #根据文件中列举的py库进行加载123- dockerflie可以帮助我们记录定制镜像的过程，定制完成后就是启动镜像了，那么如果我需要启动很多镜像的时候是不是得一个一个的敲命令呢？肯定不可能，我们可以用docker-compose进行配置，然后一键把所有镜像启动，这就构建出了一个服务，便于我们构建开发环境，线上部署等等。- 例如开发的流程是，从浏览器发请求，后台接收到请求之后，向数据库查询，然后返回结果，而前端开发完后还需要进行build打包，而从浏览器发请求到后台之间，还会有nginx分发请求等等，那么我们就可以利用docker轻松的搭建出这个流程```dockerfile version: ‘3.3’ services: #服务列表 nginx: #nginx服务 image: nginx #镜像名称 ports: #端口映射，AA:BB，AA是宿主机端口，BB是docker服务端口 - &quot;8888:80&quot; restart: on-failure #自动重启 volumes: #路径映射 - ./nginx:/etc/conf.d - ./gitbook:/book links: - web depends_on: #依赖，web开启后nginx才会开启 - web container_name: nginx #容器名字 web: image: volumes: - ./:/workspace command: python /work/server/app.py #命令行输入 restart: on-failure depends_on: #依赖于frontend和db服务 - frontend - db container_name: server frontend: #前端 image: node:6 working_dir: /home/work #工作路径 volumes: - ./frontend:/home/work - command: &quot;npm run build&quot; #node执行build命令打包前端资源 container_name: frontend healthcheck: test: &quot;exit 0&quot; db: image: mysql:5.7 container_name: db ports: #端口映射 - &quot;3307:3306&quot; 12345678910111213141516从上面可以看出，docker-compose便利的地方，而且docker-compose和宿主机间的通信都是通过端口进行，整个流程就是，浏览器向8888端口发出请求，映射到容器的80端口中，然后转发到后台，查询数据库之后再返回，然后我们可以用navicat工具将sql数据从3307端口导入到容器的sql实例中-----#### git是什么git可以用来做分布式版本控制，不同于基于中心化的版本控制，git记录数据的时候记录的是增量数据，即是改变的数据才会进行上传更新。了解git首先从commit对象，branch，HEAD指针对象开始，每一次的commit都会产生一个commit对象，commit对象会有两个指针，一个指针指向的是file tree的根节点，然后每个file是tree的一个结点，每个文件夹则是另一个tree的根结点，commit的另一个指针则会指向最新的commit，根据commit不断向前推进形成一条链，commitA -&gt; commitB -&gt; commitC 以此类推，而每个commit有一个唯一的hash值标记，这条链就是一条branch分支，每个git文件必定会有一个master分支，而分支则是由分支指针确定，分支指针会指向各自分支的最新提交，而HEAD则是指向分支指针，代表着目前在哪条分支上进行操作。```javascriptcommitA -&gt; commitB -&gt; commitC -&gt; commitD -&gt; commitE -&gt; commitF -&gt; commitG -&gt; commitH ^ \ ^ | \ | master commitG1 BranchA ^ | BranchB &lt;- HEAD git的状态分为untracked未跟踪, 此文件没有加入到git库，unmodify文件未修改，即版本库中的文件快照内容与文件夹中一致modified文件已修改，仅仅是修改，可以通过git add可进入暂存staged状态, 使用git checkout则丢弃修改返回到unmodify状态，staged暂存状态，执行git commit则将修改同步到库中，这时库中的文件和本地文件又变为一致, 文件为unmodify状态. 执行git reset HEAD可以取消暂存 git的优点 用户只要把工程clone下来，那么就会有一份完整的记录保存在用户本地中，这就避免了中心化储存中如果中心服务器坏了或者其他情况导致文件损坏难以修复 即使是没有网络环境，用户也可以commit到本地中，等有网络环境再push到远程仓库中 每个开发者都可以维护自己的分支进行开发 git如何使用 git add ，可以将untracked文件和modified的文件加入到暂存区中 git commit ，可以将staged状态的文件提交到库中，文件状态变为unmodify git pull ，可以从远程仓库拉取资源并合并到本地仓库中，根据commit的hash进行合并 git push，可以将本地commit的代码推到远程仓库中 git diff，可以观测文件之间的差异 git status，可以查看文件的状态 git checkout，可以切换分支，也可以检出modified状态的文件，取消修改状态变为unmodify git clone，从远程仓库拉取代码 git branch，可以查看分支情况，分支会储存在.git文件夹中的refs中 git reset，可以恢复本地的代码，默认–fixed意思是将commit的文件去掉，–hard意思是将add和commit的文件去掉，–soft则是将add的文件去掉 git log，可以查看远程仓库的commit情况，然后在里面获取hash值用于reset git reflog，可以查看本地的git操作情况 git rebase，可以将不同的分支合并到一条分支上，结果只剩一条操作分支，被合过来的分支会根据commit把正在操作的分支commit向前推进，被合过来的分支还存在，只是没有被引用了 git merge，也是将不同分支进行合并，但是结果还是会剩两条分支，然后两条分支根据最新的commit进行比较合并，在操作分支上形成新的commit]]></content>
  </entry>
  <entry>
    <title><![CDATA[JS的原型链和继承]]></title>
    <url>%2Fpost-3%2F</url>
    <content type="text"><![CDATA[原型和原型链原型prototype，在创建新函数的时候，会自动生成，而prototype中也会有一个constructor，回指创建该prototype的函数对象。 __proto__是对象或者实例中内置的[[prototype]]，其指向的是产生该对象的对象的prototype,在浏览器中提供了__proto__让我们可以访问，通过__proto__的指向形成的一个链条，就称做原型链，原型链的整个链路是：实例对象- -&gt;构造函数的prototype- -&gt;Object的prototype- -&gt;null。 我们在访问对象的属性或者方法的时候，首先从本对象寻找，如果本对象不存在该属性或者方法时，就会沿着原型链向上寻找，直至找到该属性或者方法，或者到null时停止。 这也解释了为什么数组对象上没有push，pop，shift，unshift等方法，却可以访问。 constructorconstructor属性指向的是生成该函数(对象)的函数(对象)，例如123456789101112131415var a = function()&#123;&#125;;var b = new a();var c = &#123;&#125;;var d = [];//以下皆为trueconsole.log(b.constructor === a) //因为实例b是由构造函数产生的console.log(a.constructor === Function)//函数a实际是Function的实例，同理console.log(c.constructor === Object)//空对象c是Object的实例console.log(d.constructor === Array)//空对象c是Object的实例console.log(Object.constructor === Function)//Object自身就是一个构造函数，同理console.log(Array.constructor === Function)//Array自身也是一个构造函数//---------------------------------------------------------------//首先__proto__指向的是产生该对象的对象的prototype，//也即a.prototype，prototype中也的constructor，回指创建该prototype的函数对象，也即函数aconsole.log(b.__proto__.constructor === a) 这里顺便说一下instanceof，A instanceof B 是在 A 的原型链中找 B 的 prototype，找到返回 true，找不到返回 false123456//有个奇怪的现象,下面都返回true，这是为什么呢？//因为JS中一切都继承自Object，除了最顶层的null，//所以在Function的原型链中能找到Object.prototypeconsole.log(Function instanceof Object)//而Object自身就是一个构造函数，因此在Object的原型链中也能找到Function.prototypeconsole.log(Object instanceof Function) 通过原型链实现继承由上面的分析，我们可以利用原型链实现继承的逻辑，继承是面向对象中的一个很重要的概念12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273function Dog(name)&#123; this.name = name; this.say1 = function()&#123; console.log(this.name) &#125;&#125;Dog.prototype.say2 = function()&#123; console.log(this.name)&#125;Dog.prototype.test = 1//say本来应该是所有Dog实例的共有方法，//如果放在构造函数中，那么就会导致没办法数据共享，每一个实例都有自己的属性和方法的副本，这是对资源的极大浪费//如果放在Dog.prototype中，那么利用原型链的特性，就可以让所有实例共用一个方法，//需要注意的是，由于共用了一个方法，对属性的更改是对所有实例透明的var dog1 = new Dog('lalala'); let dog2 = new Dog('wahaha');dog1.test++;//2dog2.test++;//3console.log(dog1.say1 === dog2.say1)// falseconsole.log(dog1.say2 === dog2.say2)// true//现在，我们可以尝试着去实现继承了//我们是通过原型链去实现继承的，//之前的原型链是：Dog实例 --&gt; Dog函数 --&gt; Object --&gt; null//那么现在的原型链需要改成 Dog实例 --&gt; Dog函数 --&gt; Dog父类(Animal函数) --&gt; Object --&gt; null//第一种方案，改变Dog函数的prototype，让他指向Animal的实例function Animal()&#123; this.species = 'unknown';&#125;Dog.prototype = new Animal();//这里改变后会导致prototype中的constructor改变Dog.prototype.constructor = Dog;//第二钟方案，改变Dog函数的prototype，让他指向Animal的prototypefunction Animal()&#123;&#125;Animal.prototype.species = 'unknown';Dog.prototype = Animal.prototype;//这里改变后会导致prototype中的constructor改变Dog.prototype.constructor = Dog;//第三种方案，调用apply或call,将Animal的this绑定到Dog中function Animal()&#123; this.species = 'unknown';&#125;function Dog(name)&#123; Animal.apply(this, arguments); this.name = name;&#125;//第四种方法，通过Object.create()方法实现继承，过滤掉了父类实例属性,Dog.prototype中就没有了Animal的实例化数据了//这种方法也是ES6中Class被babel编译成ES5所用的方法function Animal()&#123; this.species = 'unknown';&#125;function Dog(name)&#123; Animal.apply(this, arguments); this.name = name;&#125;//这里模拟了 Dog.prototype = Object.create(Animal.prototype)var f = function()&#123;&#125;;f.prototype = Animal.pototype;Dog.prototype = new f();Dog.__proto__ = Animal;//这里改变后会导致prototype中的constructor改变Dog.prototype.constructor = Dog;//现在就能访问到Animal中的species属性了var dog = new Dog('lalala');dog.species;//unknown 以上这些就是利用原型链实现继承的一些方法 ES6的class类有了以上的知识，我们就可以研究一下ES6的class类了，这个语法糖能让我们更容易的实现类和继承，其提供了extends，static，super等关键字 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122//这是es6的代码实现class Parent &#123; static l()&#123; console.log(222) &#125; constructor(m)&#123; this.m = m &#125; get()&#123; return this.m; &#125;&#125;class Child extends Parent &#123; constructor(n)&#123; super(4); this.n = n; &#125; get()&#123; return this.n &#125; set(a)&#123; this.n = a; &#125;&#125;//这是利用babel编译之后的es5的实现//_createClass是一个自执行函数，作用给构造函数绑定静态方法和动态方法//对于静态的static关键字声明的变量，会直接绑定在函数对象上，作为静态属性(方法)//对于在class中声明的函数方法，则会绑定在构造函数的prototype上，通过Object.definePropety方法var _createClass = function () &#123; function defineProperties(target, props) &#123; for (var i = 0; i &lt; props.length; i++) &#123; var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); &#125; &#125; return function (Constructor, protoProps, staticProps) &#123; if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; &#125;;&#125;();//如果父函数没有返回值或者返回值不为object或者function，则返回子类的thisfunction _possibleConstructorReturn(self, call) &#123; if (!self) &#123; throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); &#125; return call &amp;&amp; (typeof call === "object" || typeof call === "function") ? call : self;&#125;//_inherits就是extends关键字发挥的作用，实现了继承的功能。利用&amp;&amp;的短路特性，对superClass做了容错性处理，然后将子类Object.create()传了两个参数，一个参数是父类superClass.prototype,作用在上面解释继承的方法时讲过了，第二个参数是一个键值对，key代表着属性，value则和Object.definePropety中descriptor一样，这里改变constructor的目的，也在解释继承时讲过了，最后将subClass.__proto__指向superClassfunction _inherits(subClass, superClass) &#123; //...省略 subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, &#123; constructor: &#123; value: subClass, enumerable: false, writable: true, configurable: true &#125; &#125;); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;&#125;//_classCallCheck是保证构造函数不能被当成普通函数调用，需要用new关键字function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError("Cannot call a class as a function"); &#125;&#125;var Parent = function () &#123; _createClass(Parent, null, [&#123; key: "l", value: function l() &#123; console.log(222); &#125; &#125;]); function Parent(m) &#123; _classCallCheck(this, Parent); this.m = m; &#125; _createClass(Parent, [&#123; key: "get", value: function get() &#123; return this.m; &#125; &#125;]); return Parent;&#125;();var Child = function (_Parent) &#123; _inherits(Child, _Parent); function Child(n) &#123; _classCallCheck(this, Child); //由于在_inherits中将subClass(child).__proto__指向了superClass(Parent),所以这里即是Parent.call(this,4),即这里执行的是super函数，super也可以调用父类的静态方法， //如果父函数没有返回值或者返回值不为object或者function，则返回子类的this var _this = _possibleConstructorReturn(this, (Child.__proto__ || Object.getPrototypeOf(Child)).call(this, 4)); _this.n = n; return _this; &#125; _createClass(Child, [&#123; key: "set", value: function set(a) &#123; this.n = a; &#125; &#125;]); return Child;&#125;(Parent); 总结 通过以上分析，对原型和原型链有了更加深入和清晰的了解，也熟悉了constructor和instanceof的用法，加深了基于原型链的继承方式的了解，理清了这块知识。 在对ES6的class通过babel编译后的源码的分析中，也了解到了Object.create和Object.setPrototypeOf的用法，挖掘了如何去模拟super，extends和static的实现。]]></content>
  </entry>
  <entry>
    <title><![CDATA[异步回调的解决方案]]></title>
    <url>%2Fpost-2%2F</url>
    <content type="text"><![CDATA[发现问题在实践过程中经常会遇到a，b，c，d…等函数，后者依赖于前者请求之后的结果，或者是d依赖于a，b，c…等函数这些情形，在第一种情况中会出现回调嵌套的情形1234567a()&#123; b()&#123; c()&#123; ... &#125; &#125;&#125; 而第二种情况中，为了能更快获取到a，b，c…等的回调内容，会考虑进行并发请求，而这些又该如何解决呢？请继续往下看。 解决方案针对第一种情况，我们可以把异步回调以同步的写法表示出来12345678910111213141516171819202122232425262728function async()&#123;&#125;//传入两个参数，一个数组，一个函数//数组用来存放需要顺序执行的回调，//函数执行有两种情况，一种是顺序执行完数组中的元素后执行，另一种往下看async.prototype.waterfall = function(arr,cb) &#123; let index = 0;//标记位，标记进行到第几个回调 let len = arr.length;//记录数组长度 let callback = cb || function()&#123;&#125;//最后执行的回调，如果没有就执行一个空函数 //done是每个函数的最后一个参数，用来标记回调已经结束，执行下一个回调 let done = function()&#123; //将类数组arguments转化为数组， //done函数第一个参数控制是否直接去执行cb，如果为真则直接去执行，否则继续顺序执行 //done还能传入需要传给下一个回调的参数 var args = Array.prototype.slice.call(arguments); //如果第一个参数为真或者已经把所有函数都执行了一次，则执行最终的回调 if(args[0] || index == len) &#123; callback.apply(null，args.slice(1)); return; &#125; //如果还没执行完则继续执行 if(index&lt;len)&#123; args.push(done);//注入函数参数done arr[index++].apply(null,args.slice(1)); &#125; &#125; //启动 done(null);&#125; 主要思路就是通过一个done函数对顺序执行进行控制，然后还需要设置一个观测值记录已经执行了多少个回调。12345678910111213141516let b = new async();let c = function(done)&#123; setTimeout(function()&#123; console.log(111) done(null,"111"); &#125;,300) &#125;; let d = function(p1,done)&#123; setTimeout(function()&#123; console.log(222); done(null) &#125;,200); &#125; b.waterfall([c,d],function()&#123; console.log(3333) &#125;) 最终会顺序输出111，222，333； 针对第二种情况，在阿里文学读书签约活动中遇到需要向芝麻信用和支付宝分别发起请求获取状态，对于在依赖限制情况下进行并发请求，主要思路是可以设置一个变量计数器，等到需要的依赖都返回之后执行下一个请求。123456789101112131415//假设d依赖于a,blet rec = 0;let globalData = &#123;&#125;;a()&#123; ...... //成功获取到数据后存在全局变量globalData中 globalData[aData] = &#123;...&#125;; ++ret === 2 &amp;&amp; d()&#125;b()&#123; ...... //成功获取到数据后存在全局变量globalData中 globalData[bData] = &#123;...&#125;; ++ret === 2 &amp;&amp; d()&#125; 以上的这些解决方法其实都可以用Promise进行实现。 Promise是什么Promise是在ES6中出现的一个异步解决方法，它是一个状态机，初态是Pending(待解决)，可以通过resolve和reject方法将其状态变为fulfiiling(成功)和rejected(失败)，状态一旦变化之后，那么就不会再发生改变，而且其值能一直保存下来，之后还能再获取到原来的值，而不像事件监听，如果发生的时候没监听到，那么之后再去监听也不能获取到原来的值，它还可以进行链式调用a.then().then()…，可以用来解决回调地狱的问题。 Promise的用法 区分Promise.all和Promise.race，它们都是需要传入一个数组作为参数，数组中的元素都是promise对象，前者需要等到数组中所有promise对象的状态都确定之后才会继续往下执行，而后者则是哪个promise对象的状态先确定则将其返回的值作为参数继续往下执行。 resolve和reject，在new Promise实例的时候，需要传入一个函数fn作为参数，而函数中还有两个参数，就是resolve和reject(当然也可以用其他命名)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//fn就是创建实例时传入的参数，promise则是指向Promise实例的上下文function doResolve(fn, promise) &#123; //记录下是否已经执行 var done = false; //tryCallTwo就是将两个函数参数注入到fn中并执行fn var res = tryCallTwo(fn, function (value) &#123; //这里就是只有第一个resolve或者reject能生效的原因，调用过一次resolve或者reject后done变为true if (done) return; done = true; //调用Promise内部定义的resolve函数，并将值作为参数传到then方法中 resolve(promise, value); &#125;, function (reason) &#123; if (done) return; done = true; reject(promise, reason); &#125;); if (!done &amp;&amp; res === IS_ERROR) &#123; done = true; reject(promise, LAST_ERROR); &#125;&#125;function resolve(self, newValue) &#123; ......省略一部分 //如果传入的是基本类型，则直接保存在_value， //如果传入的值是对象或者函数，则进行处理后再保存在_value，通过doResolve循环调用实现 if ( newValue &amp;&amp; (typeof newValue === 'object' || typeof newValue === 'function') ) &#123; //获取newValue对象的then方法，也就是说可以传入一个含then属性的对象 var then = getThen(newValue); ......省略 if ( then === self.then &amp;&amp; newValue instanceof Promise ) &#123; self._state = 3; self._value = newValue; finale(self); return; &#125; else if (typeof then === 'function') &#123;//如果then是函数则执行resolve doResolve(then.bind(newValue), self); return; &#125; &#125; self._state = 1; self._value = newValue; finale(self); 从上面可以看出，在new Promise实例的时候，需要传入一个函数fn或者是含then属性的对象作为参数，然后该参数会通过doResolve方法注入两个函数参数(实现resolve和reject的功能)，resolve中还能传入参数，分别是基本类型，function，另一个promise，最后将结果保存在_value中，接着我们可以通过then方法进行链式调用，而_value中的的值则传递给then作为then的参数，主要是通过handleResolve方法实现的，而且在调用then会返回一个新的promise实例，从而保证了promise的状态只能变更一次的效果12345678910111213141516171819202122232425262728293031323334353637Promise.prototype.then = function(onFulfilled, onRejected) &#123; ......省略 //生成新的实例，并最终返回 var res = new Promise(noop); //Handler的作用是把then中传入的函数参数绑定到res的执行环境中 handle(this, new Handler(onFulfilled, onRejected, res)); return res;&#125;;function handle(self, deferred) &#123; ......省略 handleResolved(self, deferred);&#125;function handleResolved(self, deferred) &#123; asap(function() &#123; //根据promise不同的状态执行不同的函数，1是成功，2是失败 var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected; //如果cb是null，那么就会直接将_value中的值传递下去 if (cb === null) &#123; if (self._state === 1) &#123; resolve(deferred.promise, self._value); &#125; else &#123; reject(deferred.promise, self._value); &#125; return; &#125; //如果是函数，则将_value的值注入作为参数，并返回函数的结果 var ret = tryCallOne(cb, self._value); if (ret === IS_ERROR) &#123; reject(deferred.promise, LAST_ERROR); &#125; else &#123; //将then函数的返回值存到_value中，实现链式调用 resolve(deferred.promise, ret); &#125; &#125;);&#125; 总结经过上面的分析和梳理，应该对promise的运行机制和使用方式也很清晰了 在new Promise实例的时候可以传入函数或者含then的对象作为参数 在then中如果传入的不是函数，那么上一个_value的值将直接传给下一个then作为参数，所以下面将会输出hahaha而不是lalala 123456let p = new Promise(function(resolve,reject)&#123; resolve('hahaha')&#125;)p.then(Promise.resolve('lalala')).then(function(arg)&#123; console.log(arg)&#125;) 为了保证状态只能改变一次，每次链式调用过程中都会创建新的promise实例 123let a = new Promise(...)b = a.then(...)console.log(a === b) //false promise中用了很多参数注入的方法，例如resolve和reject，_value的传递等]]></content>
  </entry>
  <entry>
    <title><![CDATA[wepy浅析]]></title>
    <url>%2Fpost-1%2F</url>
    <content type="text"><![CDATA[wepy是腾讯内部团队开源的一个类vue框架，相对于原生小程序，这个框架对开发流程有了更高的抽象，也降低了初学者的开发难度，可是对于vue开发者来说，开发体验也降低了。不过wepy解决了以下问题: 无法引用npm包的问题 如何进行编译 更有效的组织代码，以及组件间的通信 request的并发限制， 原生频繁使用setdata，会有性能问题 如何划分作用域 提供了slot 一、wepy是什么wepy是腾讯内部团队开源的一个类vue框架，相对于原生小程序，这个框架对开发流程有了更高的抽象，也降低了初学者的开发难度，可是对于vue开发者来说，开发体验也降低了。 二、wepy解决了什么问题 1.无法引用npm包的问题 2.如何进行编译 3.更有效的组织代码，以及组件间的通信 4.request的并发限制， 5.原生频繁使用setdata，会有性能问题 6.如何划分作用域 7.提供了slot三、wepy不足之处 1.脏检查有可能带来性能消耗，因为页面切换过程中会执行一次脏检查，如果开发者知道页面没变动，可以手动停止脏检查机制（可能可以通过设置$$phase的值解决） 2.repeat中无法使用watch 3.双向绑定过多会出现性能问题 4.一个组件的数据发生变化，全部组件的都会刷新一次，这个在无限滚动中容易出现性能问题（如果repeat过程中能分配不同的实例可能能解决）四、解决方案 1.针对原生小程序不支持npm包的问题，wepy做了改进，对package.json中的依赖包，wepy模仿require的加载机制，将文件拷贝到node_modules中，针对一些特殊的包进行了hack处理，替换了相关字段，这个是在complie-script的resolveDeps方法中解决的。 2.compile根据不同的文件名后缀调用不同的方法进行编译，compile-wpy调用resolveWpy方法进行了一系列的处理，把代码变换成xmldom进行操作，将wpy文件中的config放入rst.config中，样式放入rst.style，将components放入rst.template.components（通过正则表达式获取），而components中的props以及events属性，则放入rst.script.code中，最后拆解style、template、script，生成rst对象 12345678910111213141516rst = &#123; moduleId: moduleId, style: [], template: &#123; code: '', src: '', type: '', components: &#123;&#125;, &#125;, script: &#123; code: '', src: '', type: '', &#125;, config: &#123;&#125;,&#125;; 3.原生小程序中，一个page下有四个文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253-4.原生小程序中有并发请求限制，而wepy则通过RequestMQ方法解决了这个问题，主要是通过维护一个待请求队列和请求未返回队列，以及一个映射对象，并且通过递归进行轮询，如果超过了则等待前面的请求回来再发起下一个请求。```javascript//单例模式let RequestMQ = &#123; map: &#123;&#125;,//映射对象 mq: [],//等待发起请求 running: [],//正在进行的请求 MAX_REQUEST: 5,//最大并发数 push (param) &#123; param.t = +new Date();//生成时间戳，作为请求的识别码 while ((this.mq.indexOf(param.t) &gt; -1 || this.running.indexOf(param.t) &gt; -1)) &#123; //如果时间戳存在，则进行处理，保证识别码是唯一的 param.t += Math.random() * 10 &gt;&gt; 0;//这里右移0是为了取整 &#125; this.mq.push(param.t);//将请求放入等待发起请求的队列中 this.map[param.t] = param;//用map对象记录这个请求，以时间戳作为标记 &#125;, next () &#123; let me = this;//保存该作用域 if (this.mq.length === 0)//如果没有需要发起请求，那么直接返回 return; if (this.running.length &lt; this.MAX_REQUEST - 1) &#123; //正在发起的请求数不能超过最大允许请求数 //如果不足，那么可以从待请求队列中获取需要发起的请求 let newone = this.mq.shift(); //从映射对象中根据时间戳标识码获取实际的请求参数或者对象 let obj = this.map[newone]; let oldComplete = obj.complete; obj.complete = (...args) =&gt; &#123; //请求完成之后将请求其从正在发起的队列中移除 me.running.splice(me.running.indexOf(obj.t), 1); //并且从map映射对象中移除 delete me.map[obj.t]; //这里是安全性检查，利用&amp;&amp;的短路原理， //不太理解为什么还要再执行一次 oldComplete &amp;&amp; oldComplete.apply(obj, args); //递归调用，相当于是轮询 me.next(); &#125; //记录下该请求已经发起 this.running.push(obj.t); //调用wx.request发起请求 return wx.request(obj); &#125; &#125;, request (obj) &#123; obj = obj || &#123;&#125;; obj = (typeof(obj) === &apos;string&apos;) ? &#123;url: obj&#125; : obj; this.push(obj); return this.next(); &#125;&#125;; 5.由于小程序将逻辑层和视图层完全分离，而他们通信的时候是通过wxJSBridge 实现的方式，每次setData的调用都是一次进程间的通信过程，因此花销较大。而wepy则对其进行了优化，将所有数据收集进行脏检查之后再调用setdata。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125$apply (fn) &#123; //如果传入函数作为参数，那么会先执行函数再进行脏检查 if (typeof(fn) === 'function') &#123; fn.call(this); this.$apply(); &#125; else &#123; //如果流程中正在进行脏检查($$phase为digest)时等待，因为流程中同一时间只能有一次脏检查 if (this.$$phase) &#123; this.$$phase = '$apply'; &#125; else &#123; this.$digest(); &#125; &#125;&#125;$digest () &#123; let k; //初始值，脏检查阶段进行比对 let originData = this.$data; //脏检查开始的标识 this.$$phase = '$digest'; this.$$dc = 0; while (this.$$phase) &#123; this.$$dc++; if (this.$$dc &gt;= 3) &#123; throw new Error('Can not call $apply in $apply process'); &#125; //传入setData的参数 let readyToSet = &#123;&#125;; //组件如果有computed属性，则先执行computed中的方法 if (this.computed) &#123; for (k in this.computed) &#123; let fn = this.computed[k], val = fn.call(this); if (!util.$isEqual(this[k], val)) &#123; readyToSet[this.$prefix + k] = val; this[k] = util.$copy(val, true); &#125; &#125; &#125; //比较data的初始值和现值，深度比较，不同则进行深拷贝 for (k in originData) &#123; if (!util.$isEqual(this[k], originData[k])) &#123; //如果有watcher，则执行watch属性中对应的观测数据函数，如果是字符串，则执行methods属性中对应的函数(参数为newValue，oldValue) if (this.watch) &#123; if (this.watch[k]) &#123; if (typeof this.watch[k] === 'function') &#123; this.watch[k].call(this, this[k], originData[k]); &#125; else if (typeof this.watch[k] === 'string' &amp;&amp; typeof this.methods[k] === 'function') &#123; this.methods[k].call(this, this[k], originData[k]); &#125; &#125; &#125; //将初始值和现值不一致的数据收集到对象中，稍后执行一次setdata readyToSet[this.$prefix + k] = this[k]; this.data[k] = this[k]; //深拷贝现值到初始值中，作为下一次脏检查的初始值 originData[k] = util.$copy(this[k], true); //对repeat中的组件数据进行更新，repeat中不能watch有可能是这里的逻辑有冲突 if (this.$repeat &amp;&amp; this.$repeat[k]) &#123; let $repeat = this.$repeat[k]; this.$com[$repeat.com].data[$repeat.props] = this[k]; this.$com[$repeat.com].$setIndex(0); this.$com[$repeat.com].$apply(); &#125; //对props的值进行更新，实现父子传值的关键，以及双向绑定的关键 if (this.$mappingProps[k]) &#123; Object.keys(this.$mappingProps[k]).forEach((changed) =&gt; &#123; let mapping = this.$mappingProps[k][changed]; if (typeof(mapping) === 'object') &#123; this.$parent.$apply(); &#125; else if (changed === 'parent' &amp;&amp; !util.$isEqual(this.$parent.$data[mapping], this[k])) &#123; this.$parent[mapping] = this[k]; this.$parent.data[mapping] = this[k]; this.$parent.$apply(); &#125; else if (changed !== 'parent' &amp;&amp; !util.$isEqual(this.$com[changed].$data[mapping], this[k])) &#123; this.$com[changed][mapping] = this[k]; this.$com[changed].data[mapping] = this[k]; this.$com[changed].$apply(); &#125; &#125;); &#125; &#125; &#125; //对readyToSet对象收集到的变化数据进行一次setData //$$nextTick为视图渲染完成后，执行的回调，可以是promise，也可以是普通函数，如果在调用this.$nextTick中不传参数，则必为promise //我们可以利用this.$nextTick进行一些操作 if (Object.keys(readyToSet).length) &#123; this.setData(readyToSet, () =&gt; &#123; if (this.$$nextTick) &#123; let $$nextTick = this.$$nextTick; this.$$nextTick = null; if ($$nextTick.promise) &#123; $$nextTick(); &#125; else &#123; $$nextTick.call(this); &#125; &#125; &#125;); &#125; else &#123; if (this.$$nextTick) &#123; let $$nextTick = this.$$nextTick; this.$$nextTick = null; if ($$nextTick.promise) &#123; $$nextTick(); &#125; else &#123; $$nextTick.call(this); &#125; &#125; &#125; this.$$phase = (this.$$phase === '$apply') ? '$digest' : false; &#125;&#125;$nextTick (fn) &#123; if (typeof fn === 'undefined') &#123; return new Promise((resolve, reject) =&gt; &#123; this.$$nextTick = function () &#123; resolve(); &#125;; this.$$nextTick.promise = true; &#125;); &#125; this.$$nextTick = fn; &#125; 脏检查机制在Angular中使用，数据量大的时候具有优势，而Vue和React用的是依赖收集的方式，这需要在每次更新数据之后重新进行依赖收集，在数据量大的时候频繁的收集依赖就不如脏检查高效了。 6.通过给不同组件的变量属性加上$prefix组件名作为前缀，为组件提供了一个”作用域”，而这个前缀是components中的key值，因此如果多个同名组件设置相同的key值，就会共享同一个实例。 7.wepy提供了slot插槽的功能，这为提高组件的可复用性提供了帮助。可以将通用的组件高度抽象，像vue可以利用scope-slot进行封装12345678910&lt;toggle&gt; it's a slot.&lt;/toggle&gt;//toggle.wpy&lt;template&gt; &lt;div&gt; &lt;slot /&gt; &lt;/div&gt;&lt;/temlate&gt; 五、总结wepy比起原生小程序，对于开发过程更便捷了，在编译过程中生成了rst对象，抽象出各个组件间的信息，也支持了npm包以及解决了并发限制的问题，在解决npm包上用了拷贝的方式，以及用消息队列的方式对请求数进行控制。利用脏检查机制，找出改变的数据，然后再一次过进行setData也解决了多次setData带来的性能损耗，不过还是难以解决视图层和逻辑层进程间通信制约了数据传输不能过大的问题。以组件树这种数据结构对page和组件的关系进行构建，便于进行父子间组件通信的实现，而通过以组件命名作为前缀的变量和属性命名，让组件之间的变量有了”作用域”。针对wepy中不足的地方，我也正在思考如何解决，希望能为wepy贡献一份力。此外wepy利用了getter对事件进行劫持，实现了拦截器的效果，以及mixins复用，提供了可以作为基类组件的用法，这些都是wepy的优点， 未完待续。。。。]]></content>
  </entry>
</search>
